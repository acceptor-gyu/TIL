# 스레드, 프로세스, 코어

## 개요
운영체제의 핵심 개념인 프로세스(Process), 스레드(Thread), 그리고 CPU 코어(Core)의 개념과 관계에 대해 학습합니다.

## 상세 내용

### 프로세스 (Process)
**정의**: 실행 중인 프로그램의 인스턴스

#### 특징
- **독립적인 메모리 공간**: 각 프로세스는 고유한 메모리 영역을 가짐
  - Code (텍스트): 실행 가능한 코드
  - Data: 전역 변수, 정적 변수
  - Heap: 동적 할당 메모리
  - Stack: 지역 변수, 함수 호출 정보
- **독립적인 실행**: 다른 프로세스와 격리되어 실행
- **프로세스 간 통신 (IPC)**: 공유 메모리, 메시지 큐, 파이프 등을 통해 통신
- **Context Switching 비용**: 프로세스 전환 시 많은 자원 소모

#### 프로세스 상태
1. **New**: 프로세스 생성 중
2. **Ready**: 실행 준비 완료, CPU 대기
3. **Running**: CPU에서 실행 중
4. **Waiting (Blocked)**: I/O 작업 등을 기다리는 중
5. **Terminated**: 실행 완료

### 스레드 (Thread)
**정의**: 프로세스 내에서 실행되는 작업의 단위

#### 특징
- **공유 메모리**: 같은 프로세스의 스레드들은 Code, Data, Heap 영역을 공유
- **독립적인 Stack**: 각 스레드는 독립적인 Stack을 가짐 (지역 변수, 함수 호출 정보)
- **빠른 Context Switching**: 프로세스보다 전환 비용이 적음
- **동시성 문제**: 공유 자원 접근 시 동기화 필요 (Race Condition, Deadlock 등)

#### 스레드의 종류
1. **User-level Thread (사용자 레벨 스레드)**
   - 사용자 공간에서 라이브러리로 구현
   - 커널이 스레드 존재를 모름
   - 빠른 생성과 전환
   - 하나의 스레드가 블록되면 전체 프로세스 블록

2. **Kernel-level Thread (커널 레벨 스레드)**
   - 커널이 직접 관리
   - OS 스케줄러가 스레드 단위로 스케줄링
   - 멀티코어 활용 가능
   - 생성과 전환 비용이 상대적으로 높음

### CPU 코어 (Core)
**정의**: CPU 내에서 실제 연산을 수행하는 물리적인 처리 장치

#### 특징
- **물리적 코어**: 실제 하드웨어 처리 장치
- **논리적 코어**: 하이퍼스레딩(Hyper-Threading) 기술로 하나의 물리적 코어가 2개의 논리적 코어처럼 동작
- **병렬 처리**: 멀티코어는 실제로 여러 작업을 동시에 처리 가능
- **코어 수와 성능**: 코어가 많을수록 병렬 처리 성능 향상

#### 멀티코어와 병렬성
- **병렬성 (Parallelism)**: 실제로 동시에 여러 작업 실행 (멀티코어)
- **동시성 (Concurrency)**: 논리적으로 동시에 여러 작업 실행 (싱글코어에서도 가능)

### 프로세스, 스레드, 코어의 관계

```
[CPU]
├─ Core 1
│  ├─ Thread 1 (Process A)
│  └─ Thread 2 (Process A)
├─ Core 2
│  ├─ Thread 3 (Process A)
│  └─ Thread 4 (Process B)
└─ Core 3
   └─ Thread 5 (Process B)
```

#### 실행 흐름
1. **프로세스 생성**: OS가 프로그램을 실행하면 프로세스 생성
2. **스레드 할당**: 프로세스 내에서 하나 이상의 스레드 생성
3. **코어 스케줄링**: OS 스케줄러가 스레드를 코어에 할당
4. **Context Switching**: 시분할로 여러 스레드가 코어를 번갈아 사용

### 멀티프로세스 vs 멀티스레드

| 구분 | 멀티프로세스 | 멀티스레드 |
|------|------------|-----------|
| 메모리 | 각 프로세스 독립적 | 프로세스 내에서 공유 |
| Context Switching | 느림 (많은 자원 소모) | 빠름 (Stack만 전환) |
| 안정성 | 높음 (독립적 실행) | 낮음 (한 스레드 오류가 전체 영향) |
| 통신 | IPC 필요 (복잡) | 공유 메모리 (간단) |
| 생성/종료 비용 | 높음 | 낮음 |
| 사용 예시 | Chrome (탭마다 프로세스) | 웹 서버 (요청마다 스레드) |

### Java에서의 멀티스레딩

#### Thread 클래스 상속
```java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread running: " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();

        thread1.start();
        thread2.start();
    }
}
```

#### Runnable 인터페이스 구현
```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread running: " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        Thread thread1 = new Thread(new MyRunnable());
        Thread thread2 = new Thread(new MyRunnable());

        thread1.start();
        thread2.start();
    }
}
```

#### ExecutorService 사용 (권장)
```java
public class ThreadPoolExample {
    public static void main(String[] args) {
        // CPU 코어 수만큼 스레드 풀 생성
        int coreCount = Runtime.getRuntime().availableProcessors();
        ExecutorService executorService = Executors.newFixedThreadPool(coreCount);

        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            executorService.submit(() -> {
                System.out.println("Task " + taskId + " on " + Thread.currentThread().getName());
            });
        }

        executorService.shutdown();
    }
}
```

### 스레드 풀 (Thread Pool)

#### 개념
- 미리 생성된 스레드들을 재사용하여 성능 향상
- 스레드 생성/종료 비용 절감
- 동시 실행 스레드 수 제한으로 자원 관리

#### 적절한 스레드 풀 크기
```java
// CPU 바운드 작업: CPU 코어 수 + 1
int cpuBoundPoolSize = Runtime.getRuntime().availableProcessors() + 1;

// I/O 바운드 작업: 더 많은 스레드 허용
// 공식: 코어 수 * (1 + 대기시간/실행시간)
int ioBoundPoolSize = Runtime.getRuntime().availableProcessors() * 2;
```

### Context Switching

#### 프로세스 Context Switching
1. 현재 프로세스의 상태 저장 (PCB - Process Control Block)
   - Program Counter, Register, Memory Map 등
2. 다음 프로세스의 상태 복원
3. 메모리 매핑 테이블 교체 (비용 큼)
4. 캐시 메모리 무효화 (비용 큼)

#### 스레드 Context Switching
1. 현재 스레드의 상태 저장 (TCB - Thread Control Block)
   - Program Counter, Register, Stack Pointer 등
2. 다음 스레드의 상태 복원
3. 같은 프로세스 내 스레드면 메모리 공유 (비용 적음)
4. 캐시 일부 재사용 가능

### 실무 적용 시나리오

#### 1. CPU 집약적 작업 (CPU-bound)
- **특징**: 연산 작업이 많음 (암호화, 이미지 처리, 데이터 분석)
- **전략**: 스레드 수 ≈ CPU 코어 수
- **이유**: 코어 수보다 많으면 Context Switching 비용만 증가

#### 2. I/O 집약적 작업 (I/O-bound)
- **특징**: 네트워크, 파일, DB 접근이 많음
- **전략**: 스레드 수 > CPU 코어 수
- **이유**: I/O 대기 중에 다른 스레드가 실행 가능

#### 3. Spring Boot 애플리케이션
```java
@Configuration
public class AsyncConfig implements AsyncConfigurer {
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();

        // 기본 스레드 수
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors());

        // 최대 스레드 수
        executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * 2);

        // 큐 용량
        executor.setQueueCapacity(100);

        executor.setThreadNamePrefix("async-");
        executor.initialize();
        return executor;
    }
}
```

### 많을수록 좋은가? (최적화의 함정)

#### 코어가 많을수록 좋은가?

**결론: 작업 특성에 따라 다르며, 무조건 많다고 좋은 것은 아님**

**장점**
- 실제 병렬 처리 능력 증가
- 멀티스레드 애플리케이션 성능 향상
- 여러 프로세스 동시 실행 가능

**한계와 문제점**
1. **Amdahl's Law (암달의 법칙)**
   ```
   최대 성능 향상 = 1 / (S + (P / N))
   S: 순차 실행 부분 비율
   P: 병렬 실행 가능 부분 비율
   N: 프로세서(코어) 수
   ```
   - 프로그램에서 병렬화할 수 없는 부분이 존재
   - 예: 프로그램의 50%만 병렬화 가능하면, 무한대의 코어로도 최대 2배 향상만 가능

2. **병목 현상**
   - 공유 자원(메모리, 캐시, I/O) 경쟁 증가
   - 메모리 대역폭 한계
   - 락(Lock) 경쟁으로 대기 시간 증가

3. **비용 대비 효율**
   - 코어 추가 시 선형적 성능 향상 불가
   - 하드웨어 비용, 전력 소비, 발열 증가

**실무 예시**
```java
// 순차 처리가 많은 작업 (병렬화 어려움)
for (int i = 0; i < 1000; i++) {
    result = processSequential(result); // 이전 결과에 의존
}
// → 코어 수를 늘려도 성능 향상 미미

// 병렬 처리 가능한 작업
List<String> urls = getUrls();
urls.parallelStream()
    .map(this::fetchData)      // 독립적인 작업
    .collect(Collectors.toList());
// → 코어 수에 비례하여 성능 향상
```

#### 스레드가 많을수록 좋은가?

**결론: 과도한 스레드는 오히려 성능 저하를 야기함**

**장점**
- I/O 대기 시간 동안 다른 작업 수행 가능
- 응답성 향상

**한계와 문제점**
1. **Context Switching 오버헤드**
   ```
   스레드 수가 코어 수보다 많으면:
   → 시분할로 번갈아 실행
   → Context Switching 빈번 발생
   → CPU가 실제 작업보다 전환 작업에 시간 소모
   ```

2. **메모리 오버헤드**
   - 각 스레드마다 Stack 메모리 필요 (보통 512KB ~ 1MB)
   - 1000개 스레드 = 약 1GB 메모리 소비
   - 메모리 부족 시 OutOfMemoryError

3. **동기화 비용 증가**
   - 스레드가 많을수록 공유 자원 경쟁 증가
   - 락 대기 시간 증가
   - 처리량(Throughput) 감소

4. **스레싱(Thrashing)**
   - 과도한 스레드로 Context Switching이 너무 빈번
   - 실제 작업보다 전환에 더 많은 시간 소비
   - 시스템 전체 성능 급격히 저하

**실무 예시: 스레드 수에 따른 성능 변화**
```java
public class ThreadOverheadExample {
    public static void main(String[] args) throws InterruptedException {
        int[] threadCounts = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};
        int taskCount = 10000;

        for (int threadCount : threadCounts) {
            long startTime = System.currentTimeMillis();
            ExecutorService executor = Executors.newFixedThreadPool(threadCount);

            CountDownLatch latch = new CountDownLatch(taskCount);
            for (int i = 0; i < taskCount; i++) {
                executor.submit(() -> {
                    // 간단한 CPU 작업
                    double result = 0;
                    for (int j = 0; j < 1000; j++) {
                        result += Math.sqrt(j);
                    }
                    latch.countDown();
                });
            }

            latch.await();
            executor.shutdown();

            long elapsed = System.currentTimeMillis() - startTime;
            System.out.println("Threads: " + threadCount + ", Time: " + elapsed + "ms");
        }
    }
}

// 예상 결과 (4코어 CPU):
// Threads: 1, Time: 2000ms
// Threads: 2, Time: 1000ms
// Threads: 4, Time: 500ms     ← 최적
// Threads: 8, Time: 550ms
// Threads: 16, Time: 700ms
// Threads: 32, Time: 900ms
// Threads: 64, Time: 1200ms
// ...                         ← Context Switching 오버헤드로 성능 저하
```

**최적 스레드 수 공식**
```java
// CPU 집약적 작업
int optimalThreads = Runtime.getRuntime().availableProcessors() + 1;

// I/O 집약적 작업 (대기 시간이 있는 경우)
// 공식: 코어 수 * (1 + 대기시간/처리시간)
// 예: 대기 80%, 처리 20% → 4코어 * (1 + 4) = 20 스레드
int optimalThreads = coreCount * (1 + waitTime / computeTime);
```

#### 프로세스가 많을수록 좋은가?

**결론: 메모리와 Context Switching 비용으로 인해 제한적**

**장점**
- 독립적 실행으로 안정성 향상
- 격리된 메모리로 보안 강화

**한계와 문제점**
1. **메모리 오버헤드**
   - 각 프로세스마다 독립적인 메모리 공간
   - Code, Data, Heap, Stack 모두 별도 할당
   - 프로세스 100개 = 수 GB 메모리 소비

2. **Context Switching 비용**
   - 스레드보다 훨씬 무거움
   - 메모리 매핑 테이블 교체, 캐시 무효화
   - TLB(Translation Lookaside Buffer) 플러시

3. **IPC 복잡성**
   - 프로세스 간 통신 오버헤드
   - 공유 메모리, 소켓 등 추가 메커니즘 필요

**실무 사례**
```
Chrome 브라우저: 탭마다 프로세스 생성
- 장점: 한 탭 크래시가 다른 탭에 영향 없음
- 단점: 탭이 많으면 메모리 사용량 급증
- 해결: 최근 버전은 여러 탭을 하나의 프로세스로 그룹화
```

#### 성능 최적화 원칙

**1. 측정 기반 최적화**
```java
// 항상 성능 측정 후 조정
@Test
public void measurePerformance() {
    int[] threadCounts = {2, 4, 8, 16};
    for (int count : threadCounts) {
        long startTime = System.nanoTime();
        // 실제 작업 수행
        long duration = System.nanoTime() - startTime;
        System.out.println("Threads: " + count + ", Duration: " + duration);
    }
}
```

**2. 작업 특성에 맞는 선택**
```java
// CPU 집약적: 코어 수만큼
ExecutorService cpuBound = Executors.newFixedThreadPool(
    Runtime.getRuntime().availableProcessors()
);

// I/O 집약적: 코어 수의 2배 이상
ExecutorService ioBound = Executors.newFixedThreadPool(
    Runtime.getRuntime().availableProcessors() * 2
);

// 단기 작업: 캐시된 스레드 풀
ExecutorService shortTasks = Executors.newCachedThreadPool();
```

**3. 모니터링과 튜닝**
```java
ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
executor.setCorePoolSize(10);
executor.setMaxPoolSize(20);
executor.setQueueCapacity(100);

// 거부 정책 설정 (큐가 가득 찰 때)
executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());

// 메트릭 수집
executor.getThreadPoolExecutor().getActiveCount();    // 현재 활성 스레드
executor.getThreadPoolExecutor().getCompletedTaskCount(); // 완료된 작업 수
```

**핵심 원칙**
> "더 많은 코어, 스레드, 프로세스가 아니라, **적절한 수**를 찾는 것이 중요"
> - 작업 특성 분석 (CPU-bound vs I/O-bound)
> - 실제 측정과 프로파일링
> - 점진적 조정 (2배씩 늘려가며 테스트)
> - 모니터링 기반 동적 조정

## 핵심 정리

### 개념 정리
- **프로세스**: 독립적인 메모리 공간을 가진 실행 단위, 격리된 실행
- **스레드**: 프로세스 내 작업 단위, 메모리 공유, 빠른 전환
- **코어**: 물리적 처리 장치, 실제 병렬 처리 가능

### 관계
- 하나의 프로세스는 여러 스레드를 가질 수 있음
- 여러 스레드가 여러 코어에서 병렬 실행 가능
- 코어 수보다 많은 스레드는 시분할로 실행

### 성능 최적화
- **CPU 바운드**: 스레드 수 ≈ 코어 수
- **I/O 바운드**: 스레드 수 > 코어 수
- 스레드 풀 사용으로 생성/종료 비용 절감
- Context Switching 최소화

### 주의사항
- 멀티스레드 환경에서 동기화 필수 (Race Condition 방지)
- 무분별한 스레드 생성은 오히려 성능 저하
- 스레드 풀 크기는 작업 특성에 맞게 설정

## 참고 자료
- [Oracle Java Documentation - Concurrency](https://docs.oracle.com/javase/tutorial/essential/concurrency/)
- [Operating System Concepts (공룡책)](https://www.os-book.com/)
- [Java Concurrency in Practice](https://jcip.net/)
