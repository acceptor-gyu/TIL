# Spring Data JPA N+1 문제와 해결방법

## 개요

N+1 문제는 JPA/Hibernate를 사용할 때 가장 흔하게 발생하는 성능 이슈다. 부모 엔티티 1건을 조회하는 쿼리 1개와, 연관된 자식 엔티티를 각각 조회하는 쿼리 N개가 추가로 실행되어 총 N+1개의 쿼리가 발생하는 현상이다.

## 상세 내용

### N+1 문제란?

```java
@Entity
public class Team {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @OneToMany(mappedBy = "team", fetch = FetchType.LAZY)
    private List<Member> members = new ArrayList<>();
}

@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id")
    private Team team;
}
```

```java
List<Team> teams = teamRepository.findAll();
// 1번: SELECT * FROM team (팀 전체 조회)

for (Team team : teams) {
    team.getMembers().size(); // 프록시 초기화 시점에 추가 쿼리 발생
    // N번: SELECT * FROM member WHERE team_id = ? (팀 수만큼 반복)
}
```

팀이 100개라면 **총 101개의 쿼리**가 실행된다.

### FetchType.EAGER로 바꾸면 해결될까?

`FetchType.EAGER`로 변경하면 즉시 로딩이 되지만, N+1 문제는 **해결되지 않는다**. JPQL을 사용하는 경우(`findAll()` 포함) Hibernate는 JPQL을 먼저 SQL로 번역한 뒤, 반환된 엔티티의 EAGER 연관관계를 별도의 SELECT로 즉시 로딩하기 때문이다. 오히려 **로딩 시점만 앞당겨질 뿐** 쿼리 수는 동일하다.

```
-- FetchType.EAGER여도 동일하게 발생
SELECT * FROM team;                          -- 1번
SELECT * FROM member WHERE team_id = 1;      -- +1
SELECT * FROM member WHERE team_id = 2;      -- +1
...
SELECT * FROM member WHERE team_id = N;      -- +1
```

따라서 **기본 전략은 항상 LAZY로 두고**, 필요한 시점에 명시적으로 페치 전략을 적용하는 것이 올바른 접근이다.

---

### 해결방법 1: JOIN FETCH (JPQL)

JPQL에서 `JOIN FETCH`를 사용하면 연관 엔티티를 **한 번의 쿼리**로 함께 조회한다.

```java
public interface TeamRepository extends JpaRepository<Team, Long> {

    @Query("SELECT DISTINCT t FROM Team t JOIN FETCH t.members")
    List<Team> findAllWithMembers();
}
```

실행되는 SQL:
```sql
SELECT DISTINCT t.*, m.*
FROM team t
INNER JOIN member m ON t.id = m.team_id;
```

**주의사항:**
- `DISTINCT`를 사용하지 않으면 조인으로 인해 중복된 Team 엔티티가 반환된다
- **컬렉션 2개 이상에 JOIN FETCH를 동시에 사용하면 `MultipleBagFetchException` 발생** - Hibernate는 두 개 이상의 `List`(Bag) 타입 컬렉션을 동시에 페치할 수 없다
- 페이징(`Pageable`)과 함께 사용하면 **메모리에서 페이징**이 수행된다 (HHH000104 경고)

---

### 해결방법 2: @EntityGraph

JPA 2.1에서 추가된 `@EntityGraph`는 리포지토리 메서드 단위로 페치 전략을 지정한다.

```java
public interface TeamRepository extends JpaRepository<Team, Long> {

    @EntityGraph(attributePaths = {"members"})
    @Query("SELECT t FROM Team t")
    List<Team> findAllWithMembers();
}
```

중첩된 연관관계도 지정 가능하다:

```java
@EntityGraph(attributePaths = {"members", "members.address"})
@Query("SELECT t FROM Team t")
List<Team> findAllWithMembersAndAddress();
```

#### @EntityGraph 내부 동작 원리

**1. 기본 지연 로딩 시 (EntityGraph 미사용)**
```sql
-- 1번째: Team 조회
SELECT t.id, t.name FROM team t;

-- 2번째 이후: members 접근 시 개별 조회 (N+1 발생)
SELECT m.* FROM member m WHERE m.team_id = ?
```

**2. @EntityGraph 적용 시**

Hibernate는 Entity Graph를 **LEFT OUTER JOIN을 사용한 단일 쿼리**로 변환한다:

```sql
SELECT t.id, t.name, m.id, m.name, m.team_id
FROM team t
LEFT OUTER JOIN member m ON t.id = m.team_id
```

이를 통해 **N+1 쿼리를 1개의 쿼리로 최적화**한다.

**3. 실행 흐름**

```java
// 1. Spring Data JPA가 @EntityGraph 감지
@EntityGraph(attributePaths = {"members"})
List<Team> findAll();

// 2. Hibernate가 javax.persistence.loadgraph 힌트 설정
EntityGraph<Team> graph = entityManager.createEntityGraph(Team.class);
graph.addAttributeNodes("members");

// 3. 쿼리 실행 시 힌트 전달
entityManager.createQuery("SELECT t FROM Team t", Team.class)
    .setHint("javax.persistence.loadgraph", graph)
    .getResultList();

// 4. Hibernate가 LEFT OUTER JOIN SQL 생성
```

**4. Fetch Plan 오버라이드**

Entity Graph의 핵심 가치는 **매핑 레벨의 페치 전략을 쿼리 실행 시점에 오버라이드**할 수 있다는 점이다:

```java
@Entity
public class Team {
    // 기본은 LAZY로 설정
    @OneToMany(mappedBy = "team", fetch = FetchType.LAZY)
    private List<Member> members;
}

// 필요한 경우에만 EAGER로 오버라이드
@EntityGraph(attributePaths = {"members"})
List<Team> findAllWithMembers();

// 다른 API에서는 LAZY 유지
List<Team> findAll();
```

이를 통해 **사용 사례별로 최적화된 페치 전략**을 적용할 수 있다.

---

#### EntityGraph 타입: FETCH vs LOAD

| 타입 | JPA 힌트 | 지정된 속성 | 지정되지 않은 속성 |
|---|---|---|---|
| `FETCH` | `jakarta.persistence.fetchgraph` | EAGER | **모두 LAZY** (매핑 무시) |
| `LOAD` (기본) | `jakarta.persistence.loadgraph` | EAGER | **매핑된 FetchType 따름** |

**FETCH 타입 예시:**
```java
@Entity
public class Team {
    @OneToMany(fetch = FetchType.EAGER) // 매핑은 EAGER
    private List<Member> members;

    @OneToMany(fetch = FetchType.EAGER)
    private List<Project> projects;
}

// fetchgraph 사용 시: members만 EAGER, projects는 LAZY로 강제 변경
@EntityGraph(type = EntityGraphType.FETCH, attributePaths = {"members"})
List<Team> findAll();
```

**LOAD 타입 예시:**
```java
// loadgraph 사용 시: members는 EAGER, projects는 매핑 그대로 EAGER
@EntityGraph(type = EntityGraphType.LOAD, attributePaths = {"members"})
List<Team> findAll();
```

**중요:** `FetchType.EAGER`로 매핑된 속성은 Entity Graph로도 **LAZY로 변경할 수 없다**. 따라서 **모든 연관관계는 기본적으로 LAZY로 매핑**하고, 필요 시 Entity Graph로 EAGER를 적용하는 것이 권장된다.

---

#### @NamedEntityGraph를 활용한 재사용

선언적으로 정의하여 여러 메서드에서 재사용할 수 있다:

```java
@Entity
@NamedEntityGraph(
    name = "Team.withMembers",
    attributeNodes = @NamedAttributeNode("members")
)
public class Team { ... }

// Repository에서 참조
@EntityGraph(value = "Team.withMembers", type = EntityGraphType.LOAD)
List<Team> findAll();

@EntityGraph(value = "Team.withMembers")
Optional<Team> findById(Long id);
```

---

#### 프로그래밍 방식 사용

`EntityManager` API를 직접 사용하여 동적으로 Entity Graph를 생성할 수도 있다:

```java
@Repository
public class TeamCustomRepository {

    @PersistenceContext
    private EntityManager entityManager;

    public List<Team> findAllWithDynamicGraph() {
        EntityGraph<Team> graph = entityManager.createEntityGraph(Team.class);
        graph.addAttributeNodes("members");

        // 중첩 그래프
        Subgraph<Member> memberSubgraph = graph.addSubgraph("members");
        memberSubgraph.addAttributeNodes("address");

        return entityManager.createQuery("SELECT t FROM Team t", Team.class)
            .setHint("jakarta.persistence.loadgraph", graph)
            .getResultList();
    }
}
```

---

### 해결방법 3: @BatchSize

`@BatchSize`는 지연 로딩 시 **IN 절**을 사용하여 한 번에 여러 건을 배치로 조회한다.

```java
@Entity
public class Team {

    @BatchSize(size = 10)
    @OneToMany(mappedBy = "team", fetch = FetchType.LAZY)
    private List<Member> members = new ArrayList<>();
}
```

실행되는 SQL:
```sql
SELECT * FROM team;
-- 팀이 25개일 때, 3번의 쿼리로 해결 (10 + 10 + 5)
SELECT * FROM member WHERE team_id IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
SELECT * FROM member WHERE team_id IN (11, 12, 13, 14, 15, 16, 17, 18, 19, 20);
SELECT * FROM member WHERE team_id IN (21, 22, 23, 24, 25);
```

**글로벌 설정** (`application.yml`):

```yaml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100
```

이렇게 설정하면 모든 지연 로딩 컬렉션에 일괄 적용된다.

---

### 해결방법 4: @Fetch(FetchMode.SUBSELECT)

서브쿼리를 사용하여 연관 엔티티를 **2번의 쿼리**로 모두 조회한다.

```java
@Entity
public class Team {

    @Fetch(FetchMode.SUBSELECT)
    @OneToMany(mappedBy = "team", fetch = FetchType.LAZY)
    private List<Member> members = new ArrayList<>();
}
```

실행되는 SQL:
```sql
-- 1번째: 팀 조회
SELECT * FROM team;

-- 2번째: 서브쿼리로 관련 멤버 전체 조회
SELECT * FROM member
WHERE team_id IN (SELECT id FROM team);
```

---

### 해결방법 5: DTO Projection

연관 엔티티의 일부 필드만 필요한 경우, DTO로 직접 조회하면 N+1 자체가 발생하지 않는다.

```java
public interface TeamSummary {
    String getName();
    int getMemberCount();
}

@Query("SELECT t.name AS name, SIZE(t.members) AS memberCount FROM Team t")
List<TeamSummary> findTeamSummaries();
```

---

### 해결방법 비교

| 해결방법 | 쿼리 수 | 페이징 지원 | 다중 컬렉션 | 적용 범위 |
|---|---|---|---|---|
| JOIN FETCH | 1 | X (메모리 페이징) | X (`MultipleBagFetchException`) | 쿼리 단위 |
| @EntityGraph | 1 | X (메모리 페이징) | X (동일 제약) | 메서드 단위 |
| @BatchSize | 1 + (N/size) | O | O | 엔티티/글로벌 |
| SUBSELECT | 2 | O | O | 엔티티 단위 |
| DTO Projection | 1 | O | - | 쿼리 단위 |

### 실무 권장 전략

1. **기본 전략**: `FetchType.LAZY` + `default_batch_fetch_size` 글로벌 설정 (100 권장)
2. **특정 API 최적화**: JOIN FETCH 또는 @EntityGraph로 필요한 연관관계만 즉시 로딩
3. **조회 전용 API**: DTO Projection으로 필요한 필드만 조회
4. **쿼리 모니터링**: `spring.jpa.show-sql=true`로 개발 중 쿼리 수 확인

```yaml
# 개발 환경 쿼리 모니터링 설정
spring:
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        default_batch_fetch_size: 100
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.orm.jdbc.bind: TRACE
```

## 핵심 정리

- N+1 문제는 1개의 부모 조회 후 N개의 자식을 개별 조회하여 총 N+1개 쿼리가 발생하는 성능 이슈
- `FetchType.EAGER`는 N+1을 해결하지 못하며, **항상 LAZY를 기본**으로 사용
- **JOIN FETCH**: 한 번의 쿼리로 해결하지만 페이징과 다중 컬렉션에 제약
- **@EntityGraph**: JOIN FETCH와 유사하되 리포지토리 메서드 단위로 선언적 적용
- **@BatchSize**: IN 절을 통한 배치 로딩으로 페이징과 다중 컬렉션 모두 지원
- **SUBSELECT**: 서브쿼리로 2번에 해결, 대량 컬렉션에 효과적
- **DTO Projection**: 필요한 필드만 조회하여 N+1 자체를 원천 차단
- 실무에서는 **글로벌 BatchSize + 필요시 JOIN FETCH/EntityGraph**를 조합하는 것이 가장 실용적

## 키워드

- **N+1 문제**: 부모 엔티티 조회 1회 + 연관된 자식 엔티티 개별 조회 N회로 인해 총 N+1번의 쿼리가 실행되는 ORM 성능 이슈
- **JOIN FETCH**: JPQL에서 연관 엔티티를 조인하여 한 번의 쿼리로 즉시 로딩하는 명시적 페치 전략
- **@EntityGraph**: JPA 2.1에서 추가된 애노테이션으로, 리포지토리 메서드 단위로 페치할 연관 엔티티를 선언적으로 지정
- **@BatchSize**: 지연 로딩 시 IN 절을 사용하여 연관 엔티티를 배치 단위로 조회하는 Hibernate 최적화 기능
- **FetchMode.SUBSELECT**: 서브쿼리를 사용하여 연관 엔티티를 2번의 쿼리로 모두 조회하는 Hibernate 페치 모드
- **DTO Projection**: 엔티티 대신 필요한 필드만 선택하여 직접 DTO로 조회하는 방식으로 N+1을 원천 차단
- **FetchType.LAZY**: 연관 엔티티를 실제 사용 시점까지 로딩을 지연하는 전략 (프록시 객체 사용)
- **MultipleBagFetchException**: 두 개 이상의 List(Bag) 타입 컬렉션에 JOIN FETCH를 동시 적용할 때 발생하는 Hibernate 예외
- **default_batch_fetch_size**: 모든 지연 로딩 컬렉션에 일괄 적용되는 Hibernate 글로벌 배치 사이즈 설정
- **JPQL**: Java Persistence Query Language - 엔티티 객체를 대상으로 하는 JPA 표준 쿼리 언어

## 참고 자료

- [Hibernate ORM 6.4 User Guide - Fetching](https://docs.hibernate.org/orm/6.4/userguide/html_single/Hibernate_User_Guide.html)
- [Baeldung - N+1 Problem in Hibernate and Spring Data JPA](https://www.baeldung.com/spring-hibernate-n1-problem)
- [Baeldung - JPA Entity Graph](https://www.baeldung.com/jpa-entity-graph)
- [Baeldung - Spring Data JPA and Named Entity Graphs](https://www.baeldung.com/spring-data-jpa-named-entity-graphs)
- [Vlad Mihalcea - JPA Entity Graph](https://vladmihalcea.com/jpa-entity-graph/)
- [Preventing N+1 SELECT problem using Spring Data JPA EntityGraph](https://tech.asimio.net/2020/11/06/Preventing-N-plus-1-select-problem-using-Spring-Data-JPA-EntityGraph.html)
- [Jakarta EE Tutorial - Creating Fetch Plans with Entity Graphs](https://jakarta.ee/learn/docs/jakartaee-tutorial/current/persist/persistence-entitygraphs/persistence-entitygraphs.html)
- [JPA Buddy - Dynamic Entity Graphs in Spring Data JPA](https://jpa-buddy.com/blog/dynamic-entity-graphs-in-spring-data-jpa/)
