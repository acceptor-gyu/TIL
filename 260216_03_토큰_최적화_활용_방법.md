# Claude 토큰 최적화 활용 방법

## 개요
Claude Code와 Claude API를 사용할 때 토큰 소비는 곧 비용과 직결됩니다. Anthropic 공식 문서에 따르면 Claude Code의 평균 비용은 개발자당 하루 약 $6이며, 90%의 사용자가 $12 이하를 소비합니다. 이 글에서는 **Claude Code 사용 시의 토큰 최적화 전략**과 **API 레벨의 토큰 절약 기법**을 공식 문서 기반으로 정리합니다.

## 상세 내용

### 1. 컨텍스트 관리 (Context Management)

Claude의 토큰 비용은 **컨텍스트 크기에 비례**합니다. 컨텍스트가 클수록 매 메시지마다 더 많은 토큰을 소비하므로, 컨텍스트를 작게 유지하는 것이 가장 효과적인 최적화입니다.

#### 작업 간 컨텍스트 초기화

```
# 작업 전환 시 반드시 컨텍스트 초기화
/rename "이전 작업 설명"   # 나중에 resume할 수 있도록 이름 지정
/clear                     # 컨텍스트 초기화

# 필요 시 이전 세션으로 복귀
/resume
```

**왜 중요한가:** 이전 작업의 컨텍스트가 남아있으면 관련 없는 내용까지 매 메시지에 포함되어 토큰이 낭비됩니다.

#### 커스텀 컴팩션 (Custom Compaction)

컨텍스트 한도에 가까워지면 Claude Code가 자동으로 대화를 요약(auto-compaction)합니다. 이때 보존할 내용을 지정할 수 있습니다:

```
/compact 코드 샘플과 API 사용법에 집중해서 요약해줘
```

CLAUDE.md에서도 컴팩션 동작을 커스터마이징할 수 있습니다:

```markdown
# Compact instructions

compact 시 테스트 출력과 코드 변경사항에 집중해주세요
```

#### 토큰 사용량 모니터링

```
/cost    # 현재 세션의 토큰 사용량과 비용 확인
```

status line에 컨텍스트 사용량을 상시 표시할 수도 있습니다.

---

### 2. 모델 선택 전략 (Model Selection)

모든 작업에 Opus를 사용할 필요는 없습니다. 작업 복잡도에 따라 모델을 전환하면 비용을 크게 절약할 수 있습니다.

| 모델 | 입력 토큰 (1M당) | 출력 토큰 (1M당) | 적합한 작업 |
|------|:--------:|:--------:|------------|
| Haiku 4.5 | $1 | $5 | 간단한 서브에이전트, 대량 처리 |
| Sonnet 4.5 | $3 | $15 | 일상적인 코딩, 분석, 대부분의 작업 |
| Opus 4.6 | $15 | $75 | 복잡한 아키텍처 결정, 다단계 추론 |

```
/model    # 세션 중 모델 전환
/config   # 기본 모델 설정
```

**실전 팁:**
- **Sonnet**으로 대부분의 코딩 작업을 처리하고, **Opus**는 복잡한 아키텍처 결정이나 다단계 추론에만 사용
- 서브에이전트 작업에는 `model: haiku`를 지정하여 비용 절감

---

### 3. Extended Thinking 최적화

Extended Thinking은 기본적으로 활성화되어 있으며 31,999 토큰의 예산이 설정되어 있습니다. thinking 토큰은 **출력 토큰으로 과금**되므로, 단순한 작업에서는 불필요한 비용이 발생합니다.

**최적화 방법:**

```bash
# 환경 변수로 thinking 토큰 제한
MAX_THINKING_TOKENS=8000

# /config에서 thinking 비활성화 가능
# /model에서 effort level 조정 (Opus 4.6)
```

**effort level에 따른 차이:**
- 최소 budget: 1,024 토큰
- 단순 작업(파일 수정, 간단한 질문): 낮은 effort 또는 비활성화
- 복잡한 작업(아키텍처 설계, 디버깅): 높은 effort

---

### 4. MCP 서버 오버헤드 줄이기

각 MCP 서버는 사용하지 않을 때에도 tool definition을 컨텍스트에 추가합니다. 이는 **idle 상태에서도 토큰을 소비**한다는 의미입니다.

```
/context    # 컨텍스트 공간을 차지하는 항목 확인
/mcp        # 설정된 서버 확인 및 비활성화
```

**최적화 전략:**

1. **CLI 도구 우선 사용**: `gh`, `aws`, `gcloud` 등의 CLI 도구는 MCP 서버보다 컨텍스트 효율적
   - MCP 서버: tool definition이 항상 컨텍스트에 존재
   - CLI 도구: 실행 시에만 컨텍스트 소비

2. **사용하지 않는 서버 비활성화**: `/mcp`에서 현재 불필요한 서버 끄기

3. **Tool Search 자동 활성화**: MCP tool description이 컨텍스트의 10%를 초과하면 자동으로 on-demand 로딩으로 전환됨
   ```bash
   # 더 낮은 임계값 설정 (5%에서 트리거)
   ENABLE_TOOL_SEARCH=auto:5
   ```

---

### 5. CLAUDE.md를 Skills로 분리

CLAUDE.md 파일은 **세션 시작 시 항상 로딩**됩니다. 여기에 모든 워크플로우 지침을 넣으면 관련 없는 작업 시에도 해당 토큰이 소비됩니다.

**Before (비효율적):**
```markdown
# CLAUDE.md (800줄)
## PR 리뷰 규칙
... (200줄)
## DB 마이그레이션 가이드
... (200줄)
## 테스트 작성 규칙
... (200줄)
```

**After (효율적):**
```markdown
# CLAUDE.md (200줄 이내)
## 핵심 규칙만 기재
```

```
# .claude/skills/pr-review/SKILL.md - 필요 시에만 로딩
# .claude/skills/db-migration/SKILL.md - 필요 시에만 로딩
```

**Skills는 호출될 때만 on-demand로 로딩**되므로 기본 컨텍스트를 작게 유지할 수 있습니다. CLAUDE.md는 ~500줄 이하로 유지하는 것이 권장됩니다.

---

### 6. 서브에이전트로 대용량 출력 격리

테스트 실행, 문서 조회, 로그 처리 등 **대용량 출력이 발생하는 작업**은 서브에이전트에 위임하면 메인 컨텍스트를 보호할 수 있습니다.

**원리:**
```
[메인 컨텍스트]
  │
  ├── "테스트를 실행하고 결과를 알려줘"
  │
  ▼
[서브에이전트 컨텍스트]  ← 10,000줄의 테스트 출력이 여기에 머묾
  │
  ▼
[메인 컨텍스트]  ← "3개 테스트 실패: auth.test.ts 라인 45, 78, 102" (요약만 반환)
```

서브에이전트의 방대한 출력은 자체 컨텍스트 내에 남고, **메인 대화에는 요약만 반환**됩니다.

---

### 7. Hooks로 전처리 최적화

커스텀 Hooks를 사용하면 Claude가 보기 전에 데이터를 전처리할 수 있습니다. 10,000줄의 로그 파일 전체를 읽는 대신, Hook이 에러만 필터링하면 수만 토큰을 수백 토큰으로 줄일 수 있습니다.

**테스트 출력 필터링 Hook 예시:**

```json
// settings.json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/hooks/filter-test-output.sh"
          }
        ]
      }
    ]
  }
}
```

```bash
#!/bin/bash
# filter-test-output.sh
input=$(cat)
cmd=$(echo "$input" | jq -r '.tool_input.command')

# 테스트 실행 시 실패 내용만 필터링
if [[ "$cmd" =~ ^(npm test|pytest|go test) ]]; then
  filtered_cmd="$cmd 2>&1 | grep -A 5 -E '(FAIL|ERROR|error:)' | head -100"
  echo "{\"hookSpecificOutput\":{\"hookEventName\":\"PreToolUse\",\"permissionDecision\":\"allow\",\"updatedInput\":{\"command\":\"$filtered_cmd\"}}}"
else
  echo "{}"
fi
```

---

### 8. API 레벨 토큰 최적화

Claude API를 직접 사용하는 경우, 추가적인 최적화가 가능합니다.

#### Prompt Caching

반복되는 시스템 프롬프트나 대용량 문서를 캐싱하여 비용과 지연 시간을 대폭 줄일 수 있습니다.

**효과:**
- 비용 최대 **90% 절감**
- 지연 시간 최대 **85% 감소**
- 캐시 읽기 토큰은 ITPM(분당 입력 토큰) 한도에 미포함 → 유효 처리량 5~10배 향상

**핵심 설정:**
- 최소 캐시 토큰: 1,024 토큰
- 기본 TTL: 5분 (사용할 때마다 갱신)
- 1시간 TTL도 가능 (캐시 쓰기 비용: 기본 입력 가격의 2배)

```python
import anthropic

client = anthropic.Anthropic()

response = client.messages.create(
    model="claude-sonnet-4-5-20250929",
    max_tokens=1024,
    system=[
        {
            "type": "text",
            "text": "매우 긴 시스템 프롬프트 또는 참조 문서...",
            "cache_control": {"type": "ephemeral"}  # 캐시 브레이크포인트
        }
    ],
    messages=[{"role": "user", "content": "질문"}]
)
```

**캐시 브레이크포인트 전략:**
- 대부분의 경우 정적 콘텐츠 끝에 **하나의 브레이크포인트**로 충분
- 시스템이 자동으로 이전 콘텐츠 블록 경계(최대 20개)에서 캐시 히트를 확인
- 다른 빈도로 업데이트되는 섹션이 있을 때만 여러 브레이크포인트 사용

#### Token-Efficient Tool Use

Claude 4 이상의 모델에서는 토큰 효율적 도구 호출이 기본 내장되어 있어 출력 토큰 소비를 최대 **70% 절감**할 수 있습니다.

```python
# Claude 3.7 Sonnet: 베타 헤더 필요
response = client.beta.messages.create(
    model="claude-3-7-sonnet-20250219",
    betas=["token-efficient-tools-2025-02-19"],
    # ...
)

# Claude 4+ 모델: 기본 내장, 별도 설정 불필요
response = client.messages.create(
    model="claude-sonnet-4-5-20250929",
    # token-efficient tool use가 자동 적용
    # ...
)
```

#### max_tokens 최적화

`max_tokens`를 실제 응답 길이보다 훨씬 크게 설정하면 OTPM(분당 출력 토큰) 한도에 조기 도달할 수 있습니다.

```python
# 비효율적: 일반 응답이 500토큰인데 4096으로 설정
response = client.messages.create(max_tokens=4096, ...)

# 효율적: 예상 응답 길이에 맞게 설정
response = client.messages.create(max_tokens=500, ...)
```

---

### 9. 효율적인 작업 습관

코드나 설정이 아닌, **작업 방식** 자체를 개선하는 것도 중요합니다.

**구체적인 프롬프트 작성:**
```
# 비효율적 (광범위한 스캔 유발)
"이 코드베이스를 개선해줘"

# 효율적 (최소한의 파일 읽기)
"auth.ts의 login 함수에 입력 검증을 추가해줘"
```

**Plan Mode 활용 (Shift+Tab):**
- 복잡한 작업 전에 Plan Mode에서 먼저 탐색 + 계획 수립
- 잘못된 방향으로 구현 → 롤백 → 재시도하는 비용 방지

**조기 방향 수정:**
- 잘못된 방향으로 가고 있으면 `Escape`로 즉시 중단
- `/rewind` 또는 `Escape` 두 번으로 이전 체크포인트로 복원

**점진적 테스트:**
- 한 파일씩 작성 → 테스트 → 다음 파일로 진행
- 문제를 조기에 발견하면 수정 비용이 저렴

---

### 10. 컨텍스트 엔지니어링 (Context Engineering)

컨텍스트 엔지니어링은 AI 코딩 어시스턴트의 성능을 극대화하기 위해 **컨텍스트 윈도우의 토큰 활용을 최적화하는 기법**입니다. 단순히 프롬프트를 작성하는 것을 넘어, Claude가 효율적으로 작업할 수 있는 환경을 설계하는 것입니다.

#### 컨텍스트 3대 기둥

효과적인 AI 지원 개발을 위한 3가지 핵심 컨텍스트:

1. **프로젝트 아키텍처 지식 (Project Architecture Knowledge)**
   - 클래스 계층, 라이브러리, 프레임워크, 디자인 패턴 이해
   - CLAUDE.md에 핵심 아키텍처 설명 기재

2. **제품 요구사항 문서 (Product Requirements Documentation)**
   - 사용자 스토리와 고객 인터뷰를 통한 명확한 스펙
   - 대형 기능은 Claude에게 먼저 인터뷰시키기 (`AskUserQuestion` 활용)

3. **깊은 기술 지식 (Deep Technical Knowledge)**
   - 핵심 기술, 알고리즘, 중요한 미들웨어 컴포넌트에 대한 전문 이해
   - Skills로 분리하여 on-demand 로딩

#### CLAUDE.md 마스터하기

`CLAUDE.md`는 모든 대화 시작 시 Claude가 읽는 특별한 파일입니다. 코드만으로는 추론할 수 없는 Bash 명령어, 코드 스타일, 워크플로우 규칙을 포함해야 합니다.

```bash
/init    # 현재 프로젝트 구조를 분석해서 초안 생성
```

`/init` 명령어는 빌드 시스템, 테스트 프레임워크, 코드 패턴을 자동 감지하여 초안을 생성합니다.

**CLAUDE.md 예시:**
```markdown
# 프로젝트 개요
이 프로젝트는 Node.js + Express + PostgreSQL 기반의 REST API입니다.

# 빌드 & 테스트
- 빌드: npm run build
- 테스트: npm test
- 린트: npm run lint

# 코드 스타일
- 2칸 들여쓰기
- 세미콜론 필수
- async/await 사용 (Promise.then 금지)

# 컴팩션 지침
compact 시 테스트 결과와 에러 메시지에 집중해주세요

# 중요 경로
- API 엔드포인트: src/routes/
- 비즈니스 로직: src/services/
- DB 모델: src/models/
```

#### Just-in-Time 컨텍스트 로딩

모든 데이터를 미리 로딩하지 말고, **경량 식별자**(파일 경로, 쿼리, 웹 링크)만 유지하고 필요할 때 런타임에 동적으로 로딩하세요.

```
# 비효율적
"이 10,000개 레코드를 모두 읽고 분석해줘"

# 효율적 (Just-in-Time)
"products 테이블에서 price > 100인 레코드 수를 조회해줘"
→ SELECT COUNT(*) ... (결과: 523개)
"상위 10개만 가져와서 분석해줘"
→ SELECT * ... LIMIT 10
```

Claude Code는 `head`, `tail` 같은 Bash 명령어로 대용량 데이터를 분석합니다.

#### 컨텍스트 로트 (Context Rot)

컨텍스트 윈도우가 50% 이상 차면 LLM의 정확도가 저하됩니다. 이를 "Context Rot"이라고 부릅니다. Claude Code가 todo 리스트와 마크다운 요약을 많이 사용하는 이유입니다.

**대응 전략:**
- 컨텍스트가 50%를 넘으면 `/compact` 또는 `/clear` 고려
- status line에 컨텍스트 사용량 표시 설정

#### Spec Before You Build

대형 기능은 구현 전에 Claude에게 인터뷰시키세요:

```
"사용자 인증 기능을 추가하고 싶어. 먼저 필요한 정보를 질문해줘"
```

Claude가 `AskUserQuestion`으로 기술 구현, UI/UX, 엣지 케이스, 트레이드오프 등을 질문합니다. 스펙이 완성되면 **새 세션**을 시작하여 구현에만 집중하세요. 깨끗한 컨텍스트에서 구현하면 효율이 극대화됩니다.

---

### 11. Extended Thinking 토큰 제한 전략

Extended Thinking은 복잡한 추론에 강력하지만, thinking 토큰은 **출력 토큰으로 과금**되므로 전략적 사용이 필요합니다.

#### Adaptive Thinking (Claude 4.6+)

Claude 4.6부터 `thinking: {type: "adaptive"}`와 `effort` 파라미터가 도입되었습니다.

```python
# 구식 (deprecated)
response = client.beta.messages.create(
    model="claude-opus-4-5",
    thinking={"type": "enabled", "budget_tokens": 32000},
    betas=["interleaved-thinking-2025-05-14"],
    # ...
)

# 신식 (GA)
response = client.messages.create(
    model="claude-opus-4-6",
    thinking={"type": "adaptive"},
    output_config={"effort": "high"},  # low, medium, high
    # ...
)
```

**effort 레벨:**
- `low`: 간단한 질문, 파일 수정 (thinking 최소화)
- `medium`: 일반적인 코딩 작업
- `high`: 복잡한 아키텍처 설계, 디버깅 (thinking 최대 활용)

#### 토큰 예산 설정 전략

Claude 4.5 이하 모델에서는 명시적으로 budget을 설정할 수 있습니다:

```bash
# 환경 변수로 제어
MAX_THINKING_TOKENS=8000    # 기본값: 31,999

# settings.json에서 제어
{
  "env": {
    "MAX_THINKING_TOKENS": "8000"
  }
}
```

**권장 budget:**
- 간단한 작업: 1,024~4,000 토큰
- 일반 작업: 8,000~16,000 토큰
- 복잡한 작업: 16,000~32,000 토큰

**주의:** "think harder" 같은 프롬프트는 **토큰을 추가로 할당하지 않습니다**. 예산을 늘리려면 설정을 변경해야 합니다.

#### Thinking Block Clearing (Beta)

오래된 thinking block을 자동으로 정리하여 컨텍스트를 절약하는 기능입니다:

```python
response = client.messages.create(
    model="claude-opus-4-5",
    betas=["context-management-2025-06-27"],
    # ...
)
```

#### 언제 Extended Thinking을 비활성화할까?

```
# /config에서 thinking 비활성화 가능
```

**비활성화 권장 상황:**
- 단순 파일 수정 (변수명 변경, 주석 추가)
- 간단한 질문 ("이 함수는 무엇을 하나요?")
- 반복적인 리팩토링 작업
- 비용에 민감한 대량 배치 작업

**활성화 권장 상황:**
- 복잡한 버그 디버깅
- 새로운 아키텍처 설계
- 다단계 추론이 필요한 알고리즘 설계
- 보안 취약점 분석

---

### 12. OpusPlan: 하이브리드 모델 전략

`opusplan`은 Plan Mode에서는 Opus를, 실행 모드에서는 Sonnet을 자동으로 사용하는 **하이브리드 모델 별칭**입니다.

#### OpusPlan의 작동 방식

```
사용자: "사용자 인증 시스템을 구현해줘"
     │
     ▼
[Plan Mode: Opus 4.1]
  - 아키텍처 분석
  - DB 스키마 설계
  - 보안 고려사항 검토
  - 구현 계획 수립
     │
     ▼
[Execution Mode: Sonnet 4]
  - 코드 생성
  - 테스트 작성
  - 파일 수정
```

**비용 효과:**
- Plan Mode는 전체 작업의 ~10-20% 소요
- Opus는 Sonnet 대비 **5배 비용**이지만 plan에만 사용
- 전체 비용은 Sonnet 단독 사용 대비 **1.5~2배** 수준으로 억제되면서도 Opus의 추론 품질 확보

#### 사용 방법

```bash
/model opusplan    # 세션 중 전환

claude --model opusplan    # 시작 시 설정

# 환경 변수
export ANTHROPIC_MODEL=opusplan

# settings.json
{
  "model": "opusplan"
}
```

#### 언제 OpusPlan을 사용할까?

**OpusPlan 권장:**
- 복잡한 기능 개발 (인증, 결제, 실시간 채팅)
- 레거시 코드 리팩토링
- 성능 최적화 작업
- 아키텍처 개선

**Sonnet 단독 권장:**
- 간단한 버그 수정
- UI 스타일 변경
- 문서 작성
- 테스트 추가

**Opus 단독 권장:**
- 매우 복잡한 알고리즘 설계 (구현도 Opus로)
- 보안 감사
- 다국어 번역 검증

---

### 13. settings.json 설정 전략

`settings.json`은 Claude Code의 공식 설정 파일이며, 계층적으로 적용됩니다.

#### 파일 위치 및 우선순위

1. **Managed settings** (최고 우선순위): IT/DevOps가 배포한 정책
2. **Global settings**: `~/.claude/settings.json` - 모든 프로젝트에 적용
3. **Project settings**: `.claude/settings.json` - 팀과 공유 (Git에 포함)
4. **Local project settings**: `.claude/settings.local.json` - 개인 설정 (Git 제외)

#### 토큰 최적화 설정 예시

```json
{
  "$schema": "https://json.schemastore.org/claude-code-settings.json",

  "model": "opusplan",

  "env": {
    "MAX_THINKING_TOKENS": "8000",
    "ENABLE_TOOL_SEARCH": "auto:5",
    "DISABLE_NON_ESSENTIAL_MODEL_CALLS": "1"
  },

  "permissions": {
    "allow": [
      "Bash(npm run test)",
      "Bash(npm run lint)",
      "Read(src/**)"
    ],
    "deny": [
      "Read(**/.env)",
      "Read(**/.env.*)",
      "Bash(curl *)",
      "Bash(wget *)"
    ]
  },

  "cleanupPeriodDays": 7
}
```

#### 핵심 설정 항목

**1. 모델 설정:**
```json
{
  "model": "opusplan"  // sonnet, opus, haiku, opusplan
}
```

**2. 토큰 절약 환경 변수:**
```json
{
  "env": {
    "MAX_THINKING_TOKENS": "8000",           // thinking 토큰 제한
    "ENABLE_TOOL_SEARCH": "auto:5",          // 5%에서 tool search 트리거
    "DISABLE_NON_ESSENTIAL_MODEL_CALLS": "1" // 백그라운드 호출 최소화
  }
}
```

**3. 권한 설정 (보안 + 토큰 절약):**
```json
{
  "permissions": {
    "disableBypassPermissionsMode": "disable",
    "allow": [
      "Bash(npm run *)",     // npm 명령어만 허용
      "Read(src/**)",        // src 디렉터리만 읽기
      "Write(src/**)"
    ],
    "deny": [
      "Read(**/.env)",       // 환경 변수 파일 차단
      "Read(**/node_modules/**)",  // node_modules 읽기 차단 (토큰 낭비 방지)
      "Bash(curl *)",        // 외부 네트워크 호출 차단
      "Bash(sudo *)"         // sudo 차단
    ]
  }
}
```

**4. 세션 정리:**
```json
{
  "cleanupPeriodDays": 7  // 7일 후 오래된 세션 자동 정리
}
```

#### 팀 설정 vs 개인 설정

**`.claude/settings.json` (팀 공유 - Git에 포함):**
```json
{
  "model": "sonnet",
  "permissions": {
    "allow": [
      "Bash(npm run test)",
      "Bash(npm run lint)"
    ]
  }
}
```

**`.claude/settings.local.json` (개인 - .gitignore에 추가):**
```json
{
  "model": "opusplan",  // 개인적으로 opusplan 선호
  "env": {
    "MAX_THINKING_TOKENS": "16000"  // 더 높은 thinking budget
  }
}
```

#### Enterprise 보안 설정 예시

```json
{
  "env": {
    "CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC": "1"
  },
  "cleanupPeriodDays": 7,
  "permissions": {
    "disableBypassPermissionsMode": "disable",
    "deny": [
      "Read(**/.env)",
      "Read(**/.env.*)",
      "Read(**/secrets/**)",
      "Bash(sudo *)",
      "Bash(su *)",
      "Bash(curl *)",
      "Bash(wget *)",
      "Bash(ssh *)"
    ]
  }
}
```

#### Troubleshooting

설정 변경이 적용되지 않으면:
1. 모든 Claude Code 창 닫기
2. 새 터미널 창 열기
3. `claude` 재실행

JSON 형식 오류 확인: [JSONLint](https://jsonlint.com/)에서 검증

---

### 14. 비용 요약: 어디서 가장 많이 절약되는가

| 최적화 전략 | 절약 효과 | 적용 난이도 |
|------------|----------|:----------:|
| /clear로 컨텍스트 초기화 | 높음 | 낮음 |
| 모델 선택 (Sonnet vs Opus) | 매우 높음 (5배 차이) | 낮음 |
| Prompt Caching (API) | 최대 90% | 중간 |
| CLAUDE.md → Skills 분리 | 중간 | 중간 |
| MCP 서버 정리 | 중간 | 낮음 |
| Extended Thinking 조정 | 중간~높음 | 낮음 |
| 서브에이전트 위임 | 높음 | 중간 |
| Hooks 전처리 | 높음 | 높음 |
| 구체적 프롬프트 | 중간 | 낮음 |

## 핵심 정리
- 토큰 비용은 **컨텍스트 크기에 비례**하므로 컨텍스트를 작게 유지하는 것이 핵심
- `/clear`로 작업 간 컨텍스트를 초기화하고, `/compact`로 요약 시 보존할 내용을 지정
- **OpusPlan**으로 Plan Mode는 Opus, 실행은 Sonnet 자동 전환 (비용 1.5~2배로 Opus 품질 확보)
- CLAUDE.md는 500줄 이하로 유지하고, 세부 지침은 **Skills로 분리**하여 on-demand 로딩
- **컨텍스트 엔지니어링 3대 기둥**: 아키텍처 지식, 요구사항 문서, 기술 지식
- Extended Thinking은 복잡한 작업에만 활성화, Claude 4.6+는 `effort` 파라미터로 제어
- **Prompt Caching**으로 API 비용 최대 90%, 지연 시간 최대 85% 절감 가능
- `settings.json`으로 토큰 절약 환경 변수 설정 (`MAX_THINKING_TOKENS`, `ENABLE_TOOL_SEARCH`)
- 컨텍스트가 50% 넘으면 정확도 저하 (Context Rot) - `/compact` 또는 `/clear` 필요

## 키워드

### 컨텍스트 윈도우 (Context Window)
Claude가 한 번에 처리할 수 있는 토큰의 총량입니다. 시스템 프롬프트, 대화 히스토리, tool definition 등 모든 것이 컨텍스트에 포함됩니다. 컨텍스트가 커질수록 매 메시지마다 처리해야 할 입력 토큰이 증가하여 비용이 상승합니다.

### Auto-Compaction (자동 요약)
컨텍스트 한도에 가까워지면 Claude Code가 자동으로 대화 히스토리를 요약하는 기능입니다. `/compact` 명령어로 수동 실행하거나, CLAUDE.md에서 요약 시 보존할 내용을 지정할 수 있습니다.

### Prompt Caching (프롬프트 캐싱)
API 호출 간에 반복되는 프롬프트 접두사를 캐싱하여 재사용하는 기능입니다. 시스템 프롬프트, 대용량 문서, 예제 등을 캐싱하면 비용을 최대 90%, 지연 시간을 최대 85%까지 줄일 수 있습니다. 기본 TTL은 5분이며 사용 시마다 갱신됩니다.

### Token-Efficient Tool Use
Claude가 도구를 호출할 때 출력 토큰을 절약하는 기능입니다. Claude 4+ 모델에서 기본 내장되어 있으며, 출력 토큰을 최대 70%까지 줄일 수 있습니다. 평균적으로 약 14%의 출력 토큰 감소 효과가 있습니다.

### Extended Thinking (확장된 사고)
Claude가 복잡한 문제를 풀 때 단계별 추론을 수행하는 기능입니다. thinking 토큰은 출력 토큰으로 과금되므로, 단순 작업에서는 비활성화하거나 budget을 낮추어 비용을 절감할 수 있습니다. 최소 budget은 1,024 토큰입니다.

### Skills (스킬)
CLAUDE.md와 달리 **호출 시에만 로딩**되는 도메인별 지침 파일입니다. `.claude/skills/` 디렉터리에 SKILL.md 파일로 정의하며, 기본 컨텍스트를 작게 유지하면서 필요 시에만 전문 지식을 로딩할 수 있습니다.

### Tool Search (도구 검색)
MCP 서버의 tool definition이 컨텍스트의 일정 비율을 초과하면 자동으로 활성화되는 on-demand 도구 로딩 기능입니다. 사용하지 않는 도구의 definition이 컨텍스트를 차지하지 않도록 하여 토큰을 절약합니다. `ENABLE_TOOL_SEARCH=auto:<N>`으로 임계값을 조정할 수 있습니다.

### 서브에이전트 (Sub-Agent)
메인 대화에서 분리된 별도의 컨텍스트 윈도우에서 작업을 수행하는 에이전트입니다. 테스트 실행, 로그 분석 등 대용량 출력이 예상되는 작업을 위임하면, 방대한 출력이 메인 컨텍스트를 오염시키지 않고 요약만 반환됩니다.

### Hooks (훅)
Claude Code의 도구 실행 전후에 자동으로 실행되는 커스텀 셸 스크립트입니다. `PreToolUse`, `PostToolUse` 등의 이벤트에 바인딩하여 데이터를 전처리하면, Claude가 불필요하게 큰 데이터를 읽지 않도록 필터링할 수 있습니다.

### 컨텍스트 엔지니어링 (Context Engineering)
AI 코딩 어시스턴트의 성능을 극대화하기 위해 컨텍스트 윈도우의 토큰 활용을 최적화하는 기법입니다. 프로젝트 아키텍처 지식, 제품 요구사항 문서, 깊은 기술 지식의 3대 기둥으로 구성되며, CLAUDE.md와 Skills를 통해 구현합니다.

### Context Rot (컨텍스트 로트)
컨텍스트 윈도우가 50% 이상 차면 LLM의 정확도가 저하되는 현상입니다. 긴 대화록, 대용량 파일 읽기, 많은 tool definition이 누적되면 발생합니다. `/compact`로 요약하거나 `/clear`로 초기화하여 대응합니다.

### OpusPlan (하이브리드 모델 별칭)
Plan Mode에서는 Opus를, 실행 모드에서는 Sonnet을 자동으로 사용하는 모델 별칭입니다. Opus의 우수한 추론 능력으로 계획을 수립하고, Sonnet의 빠른 속도와 저렴한 비용으로 코드를 생성합니다. 전체 비용은 Sonnet 단독 사용 대비 1.5~2배로 억제됩니다.

### Adaptive Thinking (적응형 사고)
Claude 4.6부터 도입된 기능으로, 고정된 thinking budget 대신 `effort` 파라미터(low, medium, high)로 thinking 깊이를 제어합니다. 작업 복잡도에 따라 thinking 토큰을 자동으로 조절하여 비용을 최적화합니다.

### settings.json (설정 파일)
Claude Code의 공식 설정 파일로, 모델 선택, 환경 변수, 권한, 세션 정리 주기 등을 설정합니다. 글로벌 설정(`~/.claude/settings.json`), 프로젝트 설정(`.claude/settings.json`), 로컬 설정(`.claude/settings.local.json`)으로 계층화되며, 우선순위에 따라 적용됩니다.

## 참고 자료
- [Claude Code 비용 관리 공식 문서](https://code.claude.com/docs/en/costs)
- [Claude Code Best Practices 공식 문서](https://code.claude.com/docs/en/best-practices)
- [Claude Code Settings 공식 문서](https://code.claude.com/docs/en/settings)
- [Model Configuration 공식 문서](https://code.claude.com/docs/en/model-config)
- [Prompt Caching 공식 문서](https://platform.claude.com/docs/en/build-with-claude/prompt-caching)
- [Token-Efficient Tool Use 공식 문서](https://platform.claude.com/docs/en/agents-and-tools/tool-use/token-efficient-tool-use)
- [Token-Saving Updates 블로그](https://claude.com/blog/token-saving-updates)
- [Claude Skills 공식 문서](https://code.claude.com/docs/en/skills)
- [Claude Hooks 공식 문서](https://code.claude.com/docs/en/hooks)
- [Claude's Context Engineering Secrets (Bojie Li)](https://01.me/en/2025/12/context-engineering-from-claude/)
- [Effective Context Engineering for AI Agents (Anthropic Blog)](https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents)
