# 동시성 테스트

## 개요
멀티스레드 환경에서 발생할 수 있는 동시성 문제를 검증하기 위한 테스트 방법과 도구에 대해 학습합니다.

## 상세 내용

### 동시성 문제란?
여러 스레드가 동시에 공유 자원에 접근할 때 발생할 수 있는 문제들:
- **Race Condition**: 여러 스레드가 동시에 데이터를 읽고 쓸 때 발생하는 경쟁 상태
- **Deadlock**: 두 개 이상의 스레드가 서로의 자원을 기다리며 무한 대기 상태
- **Starvation**: 특정 스레드가 자원을 할당받지 못하고 계속 대기하는 상태
- **Livelock**: 스레드들이 서로 양보하며 실제 작업을 진행하지 못하는 상태

### 동시성 테스트가 필요한 이유
- 프로덕션 환경에서는 다수의 사용자가 동시에 요청을 보냄
- 단일 스레드 테스트로는 발견하기 어려운 버그 존재
- 데이터 정합성 문제를 사전에 방지

### 동시성 테스트 도구 및 개념

#### CountDownLatch
- **개념**: 하나 이상의 스레드가 다른 스레드들의 작업이 완료될 때까지 대기하도록 하는 동기화 도구
- **특징**:
  - 초기 카운트 값을 설정하고, `countDown()`을 호출할 때마다 카운트 감소
  - 카운트가 0이 되면 `await()`에서 대기 중인 스레드들이 모두 실행
  - 재사용 불가능 (한 번 카운트가 0이 되면 재설정 불가)
- **사용 시나리오**:
  - 모든 스레드의 작업이 완료될 때까지 메인 스레드가 대기해야 할 때
  - N개의 병렬 작업이 모두 끝난 후 결과를 검증해야 할 때

#### CyclicBarrier
- **개념**: 여러 스레드가 특정 지점(barrier)에 도달할 때까지 서로 대기하도록 하는 동기화 도구
- **특징**:
  - 모든 스레드가 `await()`를 호출하면 동시에 실행 재개
  - 재사용 가능 (barrier를 여러 번 사용 가능)
  - 선택적으로 모든 스레드가 barrier에 도달했을 때 실행할 작업 지정 가능
- **사용 시나리오**:
  - 여러 스레드가 정확히 같은 시점에 시작해야 하는 경우
  - 멀티스레드 알고리즘에서 단계별 동기화가 필요한 경우
- **CountDownLatch vs CyclicBarrier**:
  - CountDownLatch: 한 스레드(또는 여러 스레드)가 다른 스레드들의 완료를 기다림
  - CyclicBarrier: 모든 스레드가 서로를 기다림

#### JMH (Java Microbenchmark Harness)
- **개념**: OpenJDK에서 개발한 Java 코드 마이크로벤치마킹 프레임워크
- **특징**:
  - JVM 워밍업, JIT 컴파일 최적화를 고려한 정확한 성능 측정
  - 다양한 측정 모드 제공 (처리량, 평균 시간, 샘플 시간 등)
  - 멀티스레드 환경에서의 성능 비교 가능
- **주요 어노테이션**:
  - `@Benchmark`: 벤치마크 메서드 지정
  - `@BenchmarkMode`: 측정 모드 설정 (Throughput, AverageTime, SampleTime 등)
  - `@Warmup`: 워밍업 설정
  - `@Measurement`: 실제 측정 설정
  - `@Threads`: 스레드 수 지정
  - `@State`: 벤치마크 상태 객체 범위 지정
- **사용 시나리오**:
  - 동시성 제어 방법들의 성능 비교
  - 최적화 전후 성능 측정
  - 알고리즘의 실제 처리량 측정

### 동시성 테스트 방법

#### 1. CountDownLatch를 활용한 동시 실행
```java
@Test
@DisplayName("동시에 100개의 요청이 들어올 때 재고 감소 테스트")
void concurrentStockDecreaseTest() throws InterruptedException {
    int threadCount = 100;
    ExecutorService executorService = Executors.newFixedThreadPool(32);
    CountDownLatch latch = new CountDownLatch(threadCount);

    for (int i = 0; i < threadCount; i++) {
        executorService.submit(() -> {
            try {
                stockService.decrease(1L, 1);
            } finally {
                latch.countDown();
            }
        });
    }

    latch.await();

    Stock stock = stockRepository.findById(1L).orElseThrow();
    // 100 - (100 * 1) = 0
    assertEquals(0, stock.getQuantity());
}
```

#### 2. CyclicBarrier를 활용한 동시 시작
```java
@Test
@DisplayName("여러 스레드가 동시에 시작하여 포인트 적립 테스트")
void concurrentPointAccumulationTest() throws InterruptedException {
    int threadCount = 50;
    CyclicBarrier barrier = new CyclicBarrier(threadCount);
    ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
    AtomicInteger successCount = new AtomicInteger(0);

    for (int i = 0; i < threadCount; i++) {
        executorService.submit(() -> {
            try {
                barrier.await(); // 모든 스레드가 여기서 대기
                pointService.accumulate(1L, 100);
                successCount.incrementAndGet();
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
    }

    executorService.shutdown();
    executorService.awaitTermination(10, TimeUnit.SECONDS);

    assertEquals(threadCount, successCount.get());
}
```

#### 3. JMH (Java Microbenchmark Harness)를 활용한 성능 테스트
```java
@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.SECONDS)
@State(Scope.Thread)
public class ConcurrentCacheBenchmark {

    private ConcurrentHashMap<String, String> concurrentMap;
    private HashMap<String, String> synchronizedMap;

    @Setup
    public void setup() {
        concurrentMap = new ConcurrentHashMap<>();
        synchronizedMap = new HashMap<>();
    }

    @Benchmark
    @Threads(10)
    public void testConcurrentHashMap() {
        concurrentMap.put("key", "value");
        concurrentMap.get("key");
    }

    @Benchmark
    @Threads(10)
    public void testSynchronizedHashMap() {
        synchronized (synchronizedMap) {
            synchronizedMap.put("key", "value");
            synchronizedMap.get("key");
        }
    }
}
```

### 동시성 문제 해결 방법

#### 1. Synchronized 키워드
**설명**: Java의 기본 동기화 메커니즘으로, 메서드나 블록에 대한 접근을 제어
- **장점**: 간단하고 명확한 문법, 자동으로 락 해제
- **단점**: 유연성 부족, 세밀한 제어 불가
- **적용 범위**: 단일 JVM 내에서만 동작

**실무 예시: 싱글톤 인스턴스 생성**
```java
public class CacheManager {
    private static CacheManager instance;
    private Map<String, Object> cache = new HashMap<>();

    private CacheManager() {}

    // Double-Checked Locking으로 싱글톤 인스턴스 생성
    public static CacheManager getInstance() {
        if (instance == null) {
            synchronized (CacheManager.class) {
                if (instance == null) {
                    instance = new CacheManager();
                }
            }
        }
        return instance;
    }

    // 캐시 업데이트 시 동기화
    public synchronized void updateCache(String key, Object value) {
        cache.put(key, value);
    }

    public synchronized Object getCache(String key) {
        return cache.get(key);
    }
}
```
**적용 상황**: 단일 서버 환경에서 간단한 인메모리 캐시 관리, 설정 값 업데이트, 카운터 증가 등

#### 2. ReentrantLock
**설명**: java.util.concurrent 패키지의 명시적 락 구현
- **장점**:
  - `tryLock()`: 타임아웃 설정 가능
  - `lockInterruptibly()`: 인터럽트 가능한 락
  - 공정성(fairness) 정책 설정 가능
- **단점**: 명시적으로 unlock() 호출 필요 (finally 블록에서)
- **적용 범위**: 단일 JVM 내에서만 동작

**실무 예시: 파일 업로드 처리 (타임아웃 필요)**
```java
@Service
public class FileProcessService {
    private final ReentrantLock lock = new ReentrantLock(true); // 공정 락

    public ProcessResult processFile(MultipartFile file) {
        try {
            // 5초 동안 락 획득 시도
            if (!lock.tryLock(5, TimeUnit.SECONDS)) {
                return ProcessResult.fail("다른 파일 처리 중입니다. 잠시 후 다시 시도해주세요.");
            }

            try {
                // 무거운 파일 처리 작업
                String savedPath = saveFile(file);
                processMetadata(savedPath);
                return ProcessResult.success(savedPath);
            } finally {
                lock.unlock();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return ProcessResult.fail("파일 처리가 중단되었습니다.");
        }
    }
}
```
**적용 상황**:
- 대용량 파일 업로드/처리 (타임아웃 필요)
- 공정한 순서로 작업 처리가 필요한 경우 (fairness = true)
- 외부 API 호출 시 동시 요청 제한

#### 3. 낙관적 락 (Optimistic Lock)
**설명**: 데이터 충돌이 자주 발생하지 않을 것이라고 가정하고, 커밋 시점에 충돌을 검사
- **작동 원리**:
  - `@Version` 필드를 사용하여 엔티티의 버전 관리
  - 조회 시 버전 값을 함께 읽어옴
  - 업데이트 시 버전 값을 비교하여 변경 여부 확인
  - 버전이 다르면 `OptimisticLockException` 발생
- **장점**:
  - DB 락을 사용하지 않아 성능 우수
  - 충돌이 적은 환경에서 효율적
- **단점**:
  - 충돌 발생 시 재시도 로직 필요
  - 충돌이 빈번하면 성능 저하
- **사용 시나리오**: 읽기가 많고 쓰기가 적은 경우

**실무 예시: 게시글 수정 (동시 수정 충돌 방지)**
```java
@Entity
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;
    private String content;
    private Long viewCount;

    @Version
    private Long version;

    public void update(String title, String content) {
        this.title = title;
        this.content = content;
    }

    public void increaseViewCount() {
        this.viewCount++;
    }
}

@Service
@Transactional
public class PostService {
    private final PostRepository postRepository;

    public void updatePost(Long postId, PostUpdateRequest request) {
        int maxRetries = 3;
        int retryCount = 0;

        while (retryCount < maxRetries) {
            try {
                Post post = postRepository.findById(postId)
                    .orElseThrow(() -> new EntityNotFoundException("게시글을 찾을 수 없습니다."));

                post.update(request.getTitle(), request.getContent());
                postRepository.save(post);
                return;
            } catch (OptimisticLockException e) {
                retryCount++;
                if (retryCount >= maxRetries) {
                    throw new BusinessException("동시에 수정이 발생했습니다. 다시 시도해주세요.");
                }
                // 재시도 전 짧은 대기
                Thread.sleep(100 * retryCount);
            }
        }
    }
}
```
**적용 상황**:
- 게시글/댓글 수정 (대부분 조회, 가끔 수정)
- 사용자 프로필 업데이트
- 위키 문서 편집
- 조회수 증가 (충돌이 있어도 크게 문제되지 않는 경우)

#### 4. 비관적 락 (Pessimistic Lock)
**설명**: 데이터 충돌이 발생할 것이라고 가정하고, 트랜잭션 시작 시 락을 획득
- **작동 원리**:
  - 데이터 조회 시 DB 레벨에서 락 획득 (SELECT ... FOR UPDATE)
  - 트랜잭션이 완료될 때까지 다른 트랜잭션은 대기
- **락 종류**:
  - `PESSIMISTIC_READ`: 공유 락 (읽기는 가능, 쓰기는 블록)
  - `PESSIMISTIC_WRITE`: 배타 락 (읽기/쓰기 모두 블록)
  - `PESSIMISTIC_FORCE_INCREMENT`: 배타 락 + 버전 증가
- **장점**:
  - 데이터 정합성 보장
  - 충돌이 빈번한 환경에서 효율적
- **단점**:
  - 성능 저하 (다른 트랜잭션이 대기)
  - 데드락 가능성
- **사용 시나리오**: 충돌이 자주 발생하는 경우, 데이터 정합성이 매우 중요한 경우

**실무 예시: 콘서트 좌석 예매**
```java
@Entity
public class Seat {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String seatNumber;
    private boolean isReserved;
    private Long userId;

    public void reserve(Long userId) {
        if (this.isReserved) {
            throw new BusinessException("이미 예약된 좌석입니다.");
        }
        this.isReserved = true;
        this.userId = userId;
    }
}

public interface SeatRepository extends JpaRepository<Seat, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select s from Seat s where s.id = :id")
    Optional<Seat> findByIdWithLock(@Param("id") Long id);
}

@Service
@Transactional
public class ReservationService {
    private final SeatRepository seatRepository;

    public ReservationResult reserveSeat(Long seatId, Long userId) {
        // DB 레벨에서 락 획득 (다른 트랜잭션은 대기)
        Seat seat = seatRepository.findByIdWithLock(seatId)
            .orElseThrow(() -> new EntityNotFoundException("좌석을 찾을 수 없습니다."));

        // 예약 가능 여부 확인 및 예약 처리
        seat.reserve(userId);
        seatRepository.save(seat);

        return ReservationResult.success(seat);
    }
}
```
**적용 상황**:
- 콘서트/영화 좌석 예매 (동시 예약 방지)
- 한정판 상품 구매 (재고 1개)
- 계좌 이체 (잔액 차감)
- 포인트 차감 (마이너스 방지)
- 중요한 설정 값 변경

#### 5. 분산 락 (Distributed Lock)
**설명**: 여러 서버(분산 환경)에서 동작하는 애플리케이션 간의 동기화를 위한 락
- **필요성**:
  - 단일 JVM 락(Synchronized, ReentrantLock)은 분산 환경에서 동작하지 않음
  - DB 락은 DB 성능에 영향을 줄 수 있음
  - 여러 서버 인스턴스가 동시에 같은 자원에 접근하는 것을 방지
- **구현 방법**:
  - Redis (Redisson, Lettuce)
  - Zookeeper
  - Database (Named Lock)
- **Redisson 특징**:
  - Pub/Sub 기반으로 락 해제 알림 (폴링 방식보다 효율적)
  - 락 자동 갱신 (Watchdog)
  - 다양한 락 타입 제공 (공정 락, ReadWriteLock 등)
- **장점**:
  - 분산 환경에서 동시성 제어 가능
  - DB에 부하를 주지 않음
- **단점**:
  - 추가 인프라(Redis 등) 필요
  - 네트워크 지연 발생 가능
  - 락 타임아웃 설정 필요
- **사용 시나리오**:
  - 다중 서버 환경
  - 이벤트 쿠폰 발급, 선착순 티켓 예매 등

**실무 예시: 선착순 쿠폰 발급 (다중 서버 환경)**
```java
@Service
@RequiredArgsConstructor
public class CouponService {
    private final RedissonClient redissonClient;
    private final CouponRepository couponRepository;
    private final UserCouponRepository userCouponRepository;

    public CouponIssueResult issueCoupon(Long couponId, Long userId) {
        String lockKey = "coupon:issue:" + couponId;
        RLock lock = redissonClient.getLock(lockKey);

        try {
            // 10초 대기, 3초 후 자동 해제
            boolean available = lock.tryLock(10, 3, TimeUnit.SECONDS);
            if (!available) {
                return CouponIssueResult.fail("쿠폰 발급 요청이 많습니다. 잠시 후 다시 시도해주세요.");
            }

            // 쿠폰 재고 확인
            Coupon coupon = couponRepository.findById(couponId)
                .orElseThrow(() -> new EntityNotFoundException("쿠폰을 찾을 수 없습니다."));

            if (coupon.getRemainingCount() <= 0) {
                return CouponIssueResult.fail("쿠폰이 모두 소진되었습니다.");
            }

            // 중복 발급 체크
            if (userCouponRepository.existsByCouponIdAndUserId(couponId, userId)) {
                return CouponIssueResult.fail("이미 발급받은 쿠폰입니다.");
            }

            // 쿠폰 발급
            coupon.decreaseCount();
            UserCoupon userCoupon = UserCoupon.create(couponId, userId);
            userCouponRepository.save(userCoupon);

            return CouponIssueResult.success(userCoupon);

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return CouponIssueResult.fail("쿠폰 발급 중 오류가 발생했습니다.");
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}

@Service
@RequiredArgsConstructor
public class SchedulerService {
    private final RedissonClient redissonClient;

    @Scheduled(cron = "0 0 1 * * *") // 매일 새벽 1시
    public void dailyBatchJob() {
        String lockKey = "scheduler:daily-batch";
        RLock lock = redissonClient.getLock(lockKey);

        try {
            // 즉시 획득 시도, 1시간 후 자동 해제
            boolean available = lock.tryLock(0, 3600, TimeUnit.SECONDS);
            if (!available) {
                log.info("다른 서버에서 배치 작업 실행 중");
                return;
            }

            // 배치 작업 수행
            executeDailyBatch();

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```
**적용 상황**:
- 선착순 쿠폰/이벤트 (여러 서버에서 동시 발급)
- 한정 수량 상품 구매
- 스케줄러 중복 실행 방지 (다중 서버 환경)
- 분산 환경에서 순차적 처리가 필요한 작업
- API Rate Limiting (사용자별 요청 제한)

#### 동시성 제어 방법 비교

| 구분 | 범위 | 성능 | 데이터 정합성 | 사용 시나리오 |
|------|------|------|--------------|--------------|
| Synchronized | 단일 JVM | 높음 | 보장 | 간단한 동기화 |
| ReentrantLock | 단일 JVM | 높음 | 보장 | 세밀한 제어 필요 |
| Optimistic Lock | DB | 매우 높음 | 충돌 시 재시도 | 읽기 많음, 충돌 적음 |
| Pessimistic Lock | DB | 낮음 | 강력히 보장 | 충돌 빈번, 정합성 중요 |
| 분산 락 | 분산 환경 | 중간 | 보장 | 다중 서버 환경 |

### 동시성 테스트 시 주의사항

#### 1. 테스트 환경 설정
- **격리된 환경 사용**: 다른 테스트나 프로세스의 영향을 받지 않도록 격리
- **충분한 스레드 풀 크기**: ExecutorService의 스레드 풀 크기를 적절히 설정
- **타임아웃 설정**: 무한 대기 방지를 위해 항상 타임아웃 설정

#### 2. 테스트 데이터 준비
- **초기 상태 명확히**: 각 테스트 전에 데이터 초기화 (`@BeforeEach`)
- **트랜잭션 격리**: 테스트 간 데이터 간섭 방지
- **충분한 데이터**: 경계값, 엣지 케이스 고려

#### 3. 결과 검증
- **최종 상태 검증**: 모든 스레드 완료 후 결과 확인 (`latch.await()` 후)
- **원자성 연산 사용**: 카운터 등에는 `AtomicInteger`, `AtomicLong` 사용
- **로그 분석**: 경쟁 상태 발생 시 디버깅을 위한 로그 추가

#### 4. 락 사용 시 주의사항
- **데드락 방지**:
  - 락 획득 순서를 일관되게 유지
  - 타임아웃 설정 (`tryLock(timeout)`)
  - 필요한 최소한의 범위에만 락 적용
- **락 해제 보장**:
  - 항상 `finally` 블록에서 unlock
  - 분산 락 사용 시 `isHeldByCurrentThread()` 확인
- **락 대기 시간 설정**: 무한 대기 방지

#### 5. 성능 고려사항
- **워밍업**: JVM 워밍업을 위해 여러 번 실행 후 측정
- **GC 영향 최소화**: 테스트 전 `System.gc()` 호출 고려 (선택적)
- **적절한 스레드 수**: 너무 많으면 컨텍스트 스위칭 오버헤드 발생

#### 6. 재시도 로직 테스트
- **낙관적 락 사용 시**: 재시도 로직이 제대로 동작하는지 확인
- **재시도 횟수 제한**: 무한 재시도 방지
- **지수 백오프**: 재시도 간격을 점진적으로 증가

#### 7. 트랜잭션 주의사항
- **트랜잭션 범위**: 락 범위와 트랜잭션 범위가 일치하는지 확인
- **격리 수준**: 필요에 따라 격리 수준 조정 (`@Transactional(isolation = ...)`)
- **읽기 전용 최적화**: 조회만 하는 경우 `@Transactional(readOnly = true)`

#### 8. 실패 시나리오 테스트
- **타임아웃 발생**: 락 획득 실패 시 처리 로직 검증
- **예외 발생**: 롤백이 올바르게 동작하는지 확인
- **부분 실패**: 일부 스레드만 실패하는 경우 대응

### 동시성 테스트 도구

#### 1. Jmeter
- GUI 기반 부하 테스트 도구
- HTTP 요청을 동시에 여러 번 보내서 서버 성능 측정

#### 2. nGrinder
- 네이버에서 개발한 성능 테스트 플랫폼
- 스크립트 기반 시나리오 작성
- 분산 환경에서 대규모 부하 테스트 가능

#### 3. Gatling
- Scala 기반 부하 테스트 도구
- DSL을 사용한 시나리오 작성
- 실시간 리포트 제공

#### 4. Apache Bench (ab)
```bash
ab -n 1000 -c 100 http://localhost:8080/api/stock/decrease
```
- `-n`: 총 요청 수
- `-c`: 동시 요청 수

## 핵심 정리

### 동시성 테스트 도구
- **CountDownLatch**: 여러 스레드의 작업 완료를 대기 (재사용 불가)
- **CyclicBarrier**: 여러 스레드가 동시에 시작하도록 동기화 (재사용 가능)
- **JMH**: JVM 워밍업과 최적화를 고려한 정확한 성능 벤치마킹

### 동시성 제어 방법
- **Optimistic Lock**: 충돌이 적을 때 효율적, 버전 관리 기반, 충돌 시 재시도 필요
- **Pessimistic Lock**: 충돌이 빈번할 때 효율적, DB 레벨 락, 성능 저하 가능
- **분산 락**: 다중 서버 환경에서 필수, Redis/Zookeeper 활용, 네트워크 지연 고려

### 주의사항
- 테스트 환경을 격리하고 타임아웃 설정 필수
- 락 해제는 항상 finally 블록에서 수행
- 데드락 방지를 위해 락 획득 순서 일관성 유지
- 낙관적 락 사용 시 재시도 로직 구현 필요
- 트랜잭션 범위와 락 범위 일치 여부 확인
- 성능과 데이터 정합성의 트레이드오프 고려하여 적절한 방법 선택

## 참고 자료
- [Java Concurrency in Practice](https://jcip.net/)
- [Spring Framework - Transaction Management](https://docs.spring.io/spring-framework/reference/data-access/transaction.html)
- [Redisson - Distributed locks and synchronizers](https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers)
