# 사용자가 웹사이트에 처음 접근했을 때 발생하는 일련의 과정

## 개요
사용자가 브라우저에서 웹사이트(예: https://www.example.com)에 접근할 때, URL 입력부터 화면에 웹페이지가 렌더링되기까지의 전체 과정을 단계별로 정리합니다.

## 상세 내용

### 1. URL 입력 및 분석
- 사용자가 브라우저 주소창에 URL을 입력하거나 링크를 클릭
- 브라우저가 URL을 파싱하여 프로토콜(http/https), 도메인, 경로, 쿼리 파라미터 등을 분석
- 브라우저 캐시에 해당 URL의 이전 응답이 있는지 확인

### 2. DNS 조회 (Domain Name System)

#### DNS란?
- **Domain Name System**: 사람이 읽을 수 있는 도메인 이름(www.example.com)을 컴퓨터가 이해할 수 있는 IP 주소(93.184.216.34)로 변환하는 분산 데이터베이스 시스템
- 인터넷의 "전화번호부" 역할
- 계층적 구조로 전 세계에 분산되어 있어 안정성과 확장성 보장

#### DNS 캐시 확인 순서
DNS 조회는 성능 최적화를 위해 여러 단계의 캐시를 확인합니다:

1. **브라우저 DNS 캐시**
   - 브라우저 메모리에 최근 조회한 DNS 레코드 저장
   - Chrome의 경우 `chrome://net-internals/#dns`에서 확인 가능
   - 가장 빠른 조회 방법

2. **OS DNS 캐시**
   - 운영체제 레벨에서 관리하는 DNS 캐시
   - macOS/Linux: `dscacheutil -q host -a name example.com`
   - Windows: `ipconfig /displaydns`

3. **로컬 hosts 파일**
   - `/etc/hosts` (Unix/Linux/macOS)
   - `C:\Windows\System32\drivers\etc\hosts` (Windows)
   - DNS보다 우선순위가 높아 도메인-IP 매핑을 직접 지정 가능
   - 주로 개발 환경이나 특정 도메인 차단에 사용

#### DNS 서버 계층 구조
캐시에 없으면 DNS 서버에 질의합니다. DNS는 계층적 구조로 구성되어 있습니다:

```
Root DNS (.)
    └── TLD DNS (.com, .net, .org, .kr)
        └── Authoritative DNS (example.com)
            └── Subdomain (www.example.com, api.example.com)
```

**1. Recursive DNS Resolver (Local DNS 서버)**
- ISP 또는 사용자가 설정한 DNS 서버 (Google DNS: 8.8.8.8, Cloudflare: 1.1.1.1)
- 클라이언트를 대신하여 DNS 쿼리를 수행하는 "대리인" 역할
- 캐싱 기능으로 반복 조회 성능 향상

**2. Root DNS 서버**
- 전 세계에 13개의 논리적 Root DNS 서버 (A~M, 물리적으로는 수백 개의 복제본)
- TLD 서버의 위치 정보만 제공
- 예: `.com`은 어디에 있는지 알려줌

**3. TLD (Top-Level Domain) DNS 서버**
- `.com`, `.net`, `.org`, `.kr` 등 최상위 도메인 관리
- Authoritative DNS 서버의 위치 정보 제공
- Verisign(`.com`, `.net`), ICANN 등이 관리

**4. Authoritative DNS 서버**
- 특정 도메인의 실제 IP 주소를 보유한 최종 권한 서버
- Route53, Cloudflare, GoDaddy 등의 DNS 호스팅 서비스
- DNS 레코드의 원본 소스

#### DNS 쿼리 방식

**재귀적 쿼리 (Recursive Query)**
- 클라이언트 → Recursive Resolver: "www.example.com의 IP 주소를 찾아주세요"
- Resolver가 모든 단계를 대신 수행하고 최종 결과만 반환
- 클라이언트 입장에서는 한 번의 요청으로 끝

**반복적 쿼리 (Iterative Query)**
- Recursive Resolver ↔ Root/TLD/Authoritative DNS 간 통신
- 각 DNS 서버가 "정확한 답" 또는 "다음에 물어볼 서버"를 반환
- Resolver가 단계적으로 각 서버에 질의

#### DNS 조회 과정 예시
`www.example.com` 조회 시:

```
1. [브라우저] → [Recursive Resolver]: www.example.com의 IP는?
2. [Resolver] → [Root DNS]: .com 서버는 어디에 있나요?
3. [Root DNS] → [Resolver]: .com TLD 서버는 192.5.6.30입니다
4. [Resolver] → [.com TLD]: example.com 서버는 어디에 있나요?
5. [.com TLD] → [Resolver]: example.com의 Authoritative DNS는 ns1.example.com입니다
6. [Resolver] → [Authoritative DNS]: www.example.com의 IP는?
7. [Authoritative DNS] → [Resolver]: 93.184.216.34입니다
8. [Resolver] → [브라우저]: 93.184.216.34입니다 (캐시에 저장, TTL 적용)
```

#### DNS 레코드 타입
Authoritative DNS는 다양한 레코드 타입을 관리합니다:

| 레코드 타입 | 설명 | 예시 |
|----------|------|------|
| **A** | IPv4 주소 매핑 | example.com → 93.184.216.34 |
| **AAAA** | IPv6 주소 매핑 | example.com → 2606:2800:220:1:248:1893:25c8:1946 |
| **CNAME** | 별칭(Canonical Name) | www.example.com → example.com |
| **MX** | 메일 서버 주소 | example.com → mail.example.com (우선순위 10) |
| **TXT** | 텍스트 정보 (SPF, DKIM 등) | "v=spf1 include:_spf.google.com ~all" |
| **NS** | 네임서버 정보 | example.com → ns1.example.com |
| **SOA** | 도메인 권한 정보 | 시리얼 번호, TTL, 관리자 이메일 등 |
| **PTR** | 역방향 DNS (IP → 도메인) | 93.184.216.34 → example.com |

#### DNS 캐싱과 TTL (Time To Live)
- **TTL**: DNS 레코드가 캐시에 유지되는 시간 (초 단위)
  - 짧은 TTL (60~300초): 빠른 변경 반영, 쿼리 부하 증가
  - 긴 TTL (3600~86400초): 성능 향상, 변경 반영 느림
- **캐시 위치별 TTL**:
  - 브라우저: 보통 60초 또는 별도 정책
  - OS: 설정에 따라 다름
  - Recursive Resolver: Authoritative DNS가 설정한 TTL 준수

#### DNS 보안
- **DNS Spoofing/Cache Poisoning**: 가짜 DNS 응답을 주입하여 사용자를 피싱 사이트로 유도
- **DNSSEC (DNS Security Extensions)**: 디지털 서명으로 DNS 응답의 무결성 검증
- **DoH (DNS over HTTPS)**: HTTPS로 DNS 쿼리를 암호화하여 프라이버시 보호
- **DoT (DNS over TLS)**: TLS로 DNS 쿼리를 암호화

#### 실제 DNS 조회 확인 방법
```bash
# 기본 DNS 조회
dig www.example.com
nslookup www.example.com

# 특정 레코드 타입 조회
dig www.example.com A
dig example.com MX

# DNS 조회 과정 추적
dig +trace www.example.com

# TTL 확인
dig www.example.com | grep "^www"
```

#### 최종 결과
- 모든 단계를 거쳐 `www.example.com` → `93.184.216.34` (IPv4) 또는 `2606:2800:220:1:248:1893:25c8:1946` (IPv6) 변환 완료
- 다음 단계인 TCP 연결을 위해 IP 주소 사용

### 3. TCP 연결 수립 (3-Way Handshake)
1. **SYN**: 클라이언트가 서버에 연결 요청 (SYN 패킷 전송)
2. **SYN-ACK**: 서버가 요청을 수락하고 응답 (SYN-ACK 패킷 전송)
3. **ACK**: 클라이언트가 확인 응답 (ACK 패킷 전송)
- TCP 연결이 수립되면 신뢰성 있는 양방향 통신 채널 생성

### 4. TLS/SSL 핸드셰이크 (HTTPS인 경우)
1. **Client Hello**: 클라이언트가 지원하는 암호화 방식, TLS 버전 전송
2. **Server Hello**: 서버가 선택한 암호화 방식과 인증서 전송
3. **인증서 검증**: 브라우저가 서버 인증서의 유효성 검증 (CA 확인)
4. **키 교환**: 대칭키 생성을 위한 키 교환 (ECDHE, RSA 등)
5. **암호화 통신 시작**: 이후 모든 통신이 대칭키로 암호화

### 5. HTTP 요청 전송
```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 ...
Accept: text/html,application/xhtml+xml
Accept-Language: ko-KR,ko;q=0.9
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Cookie: session_id=abc123
```
- HTTP 메서드, 경로, 헤더, 쿠키 등을 포함한 요청 전송

### 6. 서버 처리
1. **웹 서버 수신**: Nginx, Apache 등이 요청 수신
2. **라우팅**: 요청 URL에 따라 적절한 애플리케이션 서버로 전달
3. **애플리케이션 로직 실행**:
   - 정적 파일 요청: 파일 시스템에서 직접 읽기
   - 동적 요청: 백엔드 로직 실행, DB 조회, API 호출 등
4. **응답 생성**: HTML, JSON 등의 형식으로 응답 데이터 생성

### 7. HTTP 응답 수신
```
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 12345
Content-Encoding: gzip
Cache-Control: max-age=3600
Set-Cookie: session_id=xyz789; HttpOnly; Secure

<!DOCTYPE html>
<html>
...
</html>
```
- 상태 코드, 응답 헤더, 응답 본문을 브라우저가 수신

### 8. 브라우저 렌더링 과정

#### 8.1 HTML 파싱
- HTML을 파싱하여 **DOM(Document Object Model) 트리** 생성
- 파싱 중 외부 리소스(`<link>`, `<script>`, `<img>` 등) 발견 시 추가 요청 시작

#### 8.2 CSS 파싱
- CSS 파일을 파싱하여 **CSSOM(CSS Object Model) 트리** 생성
- 스타일 규칙 계산

#### 8.3 렌더 트리 구성
- DOM 트리와 CSSOM 트리를 결합하여 **렌더 트리(Render Tree)** 생성
- 화면에 표시될 요소만 포함 (display: none 제외)

#### 8.4 레이아웃(Reflow)
- 각 요소의 정확한 위치와 크기 계산
- 뷰포트 기준으로 박스 모델 계산

#### 8.5 페인팅(Paint)
- 렌더 트리를 순회하며 각 요소를 화면에 그림
- 레이어 단위로 픽셀 값 계산

#### 8.6 합성(Composite)
- 여러 레이어를 합성하여 최종 화면 생성
- GPU 가속 활용 가능

### 9. 추가 리소스 로드
- **CSS 파일**: `<link>` 태그로 참조된 스타일시트 다운로드
- **JavaScript 파일**: `<script>` 태그로 참조된 스크립트 다운로드
  - `async`: 비동기 다운로드 후 즉시 실행
  - `defer`: 비동기 다운로드 후 HTML 파싱 완료 시 실행
- **이미지, 폰트, 비디오** 등 미디어 리소스 다운로드
- HTTP/2 멀티플렉싱으로 병렬 다운로드 가능

### 10. JavaScript 실행
- DOM 조작, 이벤트 리스너 등록, AJAX 요청 등 실행
- React, Vue 같은 프레임워크의 경우 Virtual DOM 생성 및 렌더링
- 필요시 추가 API 호출 및 동적 콘텐츠 로드

### 11. 최종 렌더링 완료
- 모든 리소스 로드 및 스크립트 실행 완료
- `DOMContentLoaded` 이벤트 발생 (HTML 파싱 완료)
- `load` 이벤트 발생 (모든 리소스 로드 완료)
- 사용자에게 완전히 렌더링된 웹페이지 표시

## 최적화 포인트
- **DNS Prefetch**: `<link rel="dns-prefetch">`로 미리 DNS 조회
- **CDN 활용**: 정적 리소스를 지리적으로 가까운 서버에서 제공
- **캐싱 전략**: 브라우저 캐시, CDN 캐시, 서버 캐시 활용
- **리소스 압축**: Gzip, Brotli 압축으로 전송 크기 감소
- **이미지 최적화**: WebP, AVIF 포맷, Lazy Loading
- **코드 스플리팅**: 필요한 JavaScript만 먼저 로드
- **HTTP/2, HTTP/3**: 멀티플렉싱, 헤더 압축, QUIC 프로토콜 활용

## 핵심 정리
- **DNS 조회**: 도메인 → IP 주소 변환 (캐시 단계별 확인)
- **TCP 연결**: 3-Way Handshake로 신뢰성 있는 연결 수립
- **TLS 핸드셰이크**: HTTPS에서 암호화 통신을 위한 인증서 검증 및 키 교환
- **HTTP 요청/응답**: 클라이언트-서버 간 데이터 교환
- **브라우저 렌더링**: HTML 파싱 → DOM 생성 → CSSOM 생성 → 렌더 트리 → 레이아웃 → 페인팅 → 합성
- **추가 리소스**: CSS, JS, 이미지 등 병렬로 다운로드 및 처리
- **성능 최적화**: DNS prefetch, 캐싱, 압축, 코드 스플리팅 등 다양한 기법 활용

## 참고 자료
- [MDN Web Docs - How browsers work](https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work)
- [Google Developers - Critical Rendering Path](https://developers.google.com/web/fundamentals/performance/critical-rendering-path)
- [RFC 9110 - HTTP Semantics](https://datatracker.ietf.org/doc/html/rfc9110)
- [RFC 8446 - TLS 1.3](https://datatracker.ietf.org/doc/html/rfc8446)
- [DNS RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035)
