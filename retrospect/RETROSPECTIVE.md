# 대학교 수강신청 시스템 프로젝트 회고록

---

## 1. 프로젝트 개요

**목표**: 10,000명 이상의 학생이 500개 이상의 강좌에 동시 접속하는 수강신청 상황에서 정원 초과 없이 정확한 동시성 제어를 보장하는 REST API 서버 구축

**기간**: 2026년 2월 (단기 집중 개발)

**기술 스택**: Java 21 · Spring Boot 3.2+ · Spring Data JPA · H2 (MySQL 모드) · JUnit 5 · AssertJ

---

## 2. 잘 된 점 (Keep)

### 동시성 전략의 명확한 설계

가장 핵심인 **정원 초과 방지** 문제를 단순하면서도 강력한 방식으로 해결했다.

```sql
UPDATE course
SET seats_left = seats_left - 1
WHERE id = ? AND seats_left > 0
```

비관적 락 없이 DB의 Row Lock에 자연스럽게 의존하는 **원자적 조건부 업데이트** 방식을 선택했다. 구현 코드는 단 10줄 내외였고, 데드락 위험이 없으며, 스케일 아웃도 가능한 구조다. `decreaseSeatIfAvailable()` 반환값으로 성공/실패를 즉시 판단하는 설계가 직관적이었다.

### 보상 트랜잭션으로 정합성 보호

INSERT 실패 시 이미 감소된 좌석을 복구하는 보상 로직을 `REQUIRES_NEW` 전파 속성으로 분리했다. EntityManager 세션이 오염된 상태에서도 별도 트랜잭션으로 좌석을 복구하는 패턴은 깔끔했다.

### 사전 계획 문서화의 철저함

`PLAN.md`에 요구사항 분석 → 아키텍처 설계 → 도메인 모델 → API 명세 → 동시성 전략 → 테스트 계획까지 17단계 커밋 전략을 사전에 수립했다. 암묵적 요구사항(IR-01~IR-12)을 별도로 추론하고 결정 근거를 기록한 점이 특히 인상적이다. 작업 시작 전 계획 수립을 원칙으로 지켜낸 결과다.

### 문제 원인 분석과 해결 대안 문서화

`CONCURRENCY_BUG_CREDIT_LIMIT_SOLUTION.md`에서 TOCTOU(Time-of-Check-Time-of-Use) 버그를 발견하고, 비관적 락 / 낙관적 락 / 원자적 업데이트 / 분산 락 / DB 제약조건 등 5가지 해결 방안을 비교하여 문서화했다. 단순히 코드를 고치는 것이 아니라 왜 그 방법을 선택해야 하는지 근거를 남긴 점이 팀의 자산이 된다.

### 계층형 아키텍처의 일관성

`dbcore → service → api → common` 패키지 의존성 규칙을 일관되게 유지했다. 컨트롤러가 Repository를 직접 호출하거나, 엔티티가 DTO에 의존하는 등의 계층 위반이 없었다.

---

## 3. 아쉬운 점 (Problem)

### P0: 동일 학생 동시 신청 시 학점 초과 버그 (미수정)

이 프로젝트에서 가장 큰 미완성 과제다. 정원 초과는 완벽히 방어했지만, 동일 학생이 서로 다른 두 강좌를 동시에 신청하면 **18학점 제한이 우회**될 수 있다.

```
학생 A (현재 15학점 수강 중)
Thread 1: 강좌X(3학점) 신청 → 학점 조회: 15점 → 15+3=18 통과 → INSERT 성공
Thread 2: 강좌Y(3학점) 신청 → 학점 조회: 15점 → 15+3=18 통과 → INSERT 성공
결과: 총 21학점 (핵심 비즈니스 규칙 위반!)
```

`findByIdWithLock()`으로 Student에 비관적 락을 거는 방식이 이미 `CONCURRENCY_BUG_CREDIT_LIMIT_SOLUTION.md`에 설계되어 있었지만, 실제 코드에 적용되지 않은 채로 남았다. **발견 → 분석 → 문서화는 완료했으나 수정은 미완**이라는 아쉬움이 남는다.

### P0: `/health` 초기화 중 503 반환

요구사항은 `/health`가 **항상 200 OK**를 반환해야 한다고 명시하지만, 데이터 초기화 중에는 503을 반환하도록 구현되어 있었다. 평가 환경에서 서버 시작 직후 헬스체크가 실패하는 상황이 발생할 수 있는 문제였다.

올바른 방향은 `200 OK` 응답 body에 `"status": "initializing"` 같은 상태 필드를 포함하는 것이었다.

### P1: 동시성 테스트 참여 인원 미달

PROBLEM.md는 "100명이 동시에 신청"이라고 명시했지만, 통합 테스트 코드에 `int participants = 10`으로 작성되어 있었다. 기능적으로는 10명으로도 동시성이 검증되지만, 요구사항이 명시한 수치와 테스트가 일치하지 않으면 평가자에게 신뢰를 줄 수 없다.

### P1: seatsLeft 카운터와 실제 Enrollment 레코드 불일치

`DataInitializer`에서 강좌 생성 시 `seatsLeft`를 랜덤으로 설정(예: 25/40 자리 차 있음)했지만, 실제 `enrollment` 테이블에는 대응하는 레코드를 생성하지 않았다. 강좌 목록 API의 `enrolled=25`와 수강신청 내역 조회의 `0건`이 충돌하는 데이터 정합성 문제가 있었다.

### P2: 시간 충돌 감지 로직의 과단순화

```java
boolean scheduleConflict = enrolledCourses.values().stream()
    .anyMatch(schedule -> schedule.equals(course.getSchedule()));
```

실제로는 `TimeSlot` 기반의 정교한 교시 충돌 감지가 PLAN.md에 설계되어 있었지만, 구현 코드에서는 `schedule` 문자열 단순 비교로 축약되었다. 같은 문자열이 아니면 충돌 감지가 안 되므로, 실질적으로 시간 충돌 방지가 무력화된 상태였다.

---

## 4. 시도해볼 것 (Try)

### 동시성 버그 수정 우선 적용

발견된 학점 초과 TOCTOU 버그에 대해 이미 해결 방안까지 설계해두었으므로, `StudentRepository.findByIdWithLock()`을 추가하고 `EnrollmentService.enroll()`에서 적용하는 작업을 다음 이터레이션에서 즉시 진행해야 한다. 문서만 만들고 코드 반영이 안 된 상태는 "알고 있는 버그"를 방치하는 것과 같다.

### 초기 데이터 정합성 전략 통일

`seatsLeft`와 실제 enrollment 레코드 간 불일치 문제는 설계 결정을 명확히 해야 한다:
1. 초기 데이터는 모두 빈 강좌(`seatsLeft = capacity`)로 생성
2. 또는 enrollment 레코드도 함께 생성

두 방향 중 하나를 선택하고 DataInitializer를 일관성 있게 수정해야 한다.

### 테스트 코드와 요구사항 수치 일치시키기

PROBLEM.md에 명시된 "100명 동시 신청" 시나리오를 테스트 코드에 그대로 반영해야 한다. 테스트 코드는 요구사항의 증거 역할을 해야 한다.

### `/health` 응답 설계 재검토

초기화 완료 여부를 HTTP 상태 코드가 아닌 응답 body로 전달하도록 수정해야 한다. `200 OK + { "status": "initializing" }` 패턴이 더 적합하다.

---

## 5. 핵심 기술 학습

### 원자적 조건부 업데이트 패턴

이 프로젝트를 통해 **Check-Then-Act** 패턴의 위험성을 실전에서 체득했다. 조회와 업데이트를 별개로 수행하면 두 연산 사이에 항상 Race Condition이 발생할 수 있다. 정원 관리 문제는 이를 하나의 `UPDATE ... WHERE` 쿼리로 묶어서 DB 엔진의 Row Lock에 의존하는 방식으로 우아하게 해결했다.

### 보상 트랜잭션과 `REQUIRES_NEW` 전파

`DataIntegrityViolationException` 발생 시 EntityManager 세션이 오염되어 현재 트랜잭션에서는 추가 쓰기 연산을 할 수 없다. `REQUIRES_NEW`로 완전히 독립된 새 트랜잭션을 열어 보상 로직을 실행하는 패턴을 실제 코드에서 적용했다.

### 동시성 문제의 다층 방어 구조

| 위협 | 방어 수단 |
|------|---------|
| 정원 초과 | 원자적 조건부 UPDATE |
| 중복 신청 | DB UniqueConstraint + 보상 트랜잭션 |
| 학점/시간 충돌 | 애플리케이션 레벨 검증 (미완) |

완벽한 시스템은 하나의 방어막이 아닌 다층 방어 구조로 이루어진다는 것을 다시 한번 확인했다.

---

## 6. 결론

이 프로젝트는 **계획-구현-검증** 사이클을 충실히 밟은 과제였다. 핵심 기능인 정원 초과 방지는 명확하게 구현되어 동시성 테스트를 통과했고, 문서화와 분석의 수준도 높았다.

다만 발견된 버그를 코드에 반영하지 않은 채 문서에만 남긴 점, 테스트 수치가 요구사항과 다른 점, `/health` 응답 규격 위반 같이 작지만 중요한 디테일에서 아쉬움이 남는다.

> **핵심 교훈**: "알고 있는 버그"와 "고친 버그"는 완전히 다르다. 분석과 해결책까지 만들었다면, 반드시 코드에 반영하는 것으로 루프를 닫아야 한다.

---

**작성일**: 2026-02-22
