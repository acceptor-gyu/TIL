# 비관적 락과 낙관적 락

## 개요
데이터베이스에서 동시성 문제를 해결하기 위한 두 가지 주요 락 전략입니다. 비관적 락(Pessimistic Lock)은 충돌이 자주 발생할 것으로 예상하고 미리 락을 거는 방식이고, 낙관적 락(Optimistic Lock)은 충돌이 드물 것으로 예상하고 락 없이 진행하다가 커밋 시점에 충돌을 검증하는 방식입니다.

## 상세 내용

### 비관적 락 (Pessimistic Lock)

비관적 락은 트랜잭션이 시작될 때 데이터에 락을 걸어 다른 트랜잭션의 접근을 차단하는 방식입니다.

**동작 방식:**
1. 트랜잭션이 데이터를 읽을 때 `SELECT ... FOR UPDATE` 구문으로 락을 획득
2. 락이 걸린 동안 다른 트랜잭션은 해당 데이터를 읽거나 수정할 수 없음 (대기 상태)
3. 트랜잭션이 커밋 또는 롤백되면 락이 해제됨

**사용 시나리오:**
- 충돌이 빈번하게 발생하는 경우
- 데이터 정합성이 매우 중요한 경우
- 재시도 비용이 큰 경우
- 예: 재고 관리, 좌석 예약, 계좌 이체

**장점:**
- 데이터 정합성을 확실하게 보장
- 충돌 발생 시 롤백 비용이 없음

**단점:**
- 락 대기로 인한 성능 저하
- 데드락(Deadlock) 발생 가능성
- 동시성이 낮아짐
- 락을 오래 유지하면 다른 트랜잭션이 블로킹됨

**SQL 예시:**
```sql
-- MySQL/PostgreSQL
BEGIN;
SELECT * FROM product WHERE id = 1 FOR UPDATE;
UPDATE product SET stock = stock - 1 WHERE id = 1;
COMMIT;
```

**JPA 예시:**
```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Product p WHERE p.id = :id")
Optional<Product> findByIdWithPessimisticLock(@Param("id") Long id);
```

### 낙관적 락 (Optimistic Lock)

낙관적 락은 락을 사용하지 않고 버전 정보를 활용하여 충돌을 검증하는 방식입니다.

**동작 방식:**
1. 데이터를 읽을 때 버전 정보(version 컬럼)를 함께 조회
2. 데이터를 수정할 때 WHERE 절에 버전 조건을 포함
3. 업데이트 시 버전이 일치하면 성공, 불일치하면 실패 (다른 트랜잭션이 수정함)
4. 실패 시 애플리케이션 레벨에서 재시도 로직 구현

**사용 시나리오:**
- 충돌이 드문 경우
- 읽기가 많고 쓰기가 적은 경우
- 높은 동시성이 필요한 경우
- 예: 게시글 조회수, 좋아요 수, 통계 데이터

**장점:**
- 락을 사용하지 않아 성능이 우수
- 데드락이 발생하지 않음
- 높은 동시성 처리 가능

**단점:**
- 충돌 시 재시도 로직이 필요
- 충돌이 빈번하면 오히려 성능 저하
- 애플리케이션 레벨에서 예외 처리 필요

**SQL 예시:**
```sql
-- 1. 읽기
SELECT id, name, stock, version FROM product WHERE id = 1;
-- version = 10

-- 2. 수정 (버전 체크 포함)
UPDATE product
SET stock = stock - 1, version = version + 1
WHERE id = 1 AND version = 10;
-- 업데이트된 행이 0이면 충돌 발생
```

**JPA 예시:**
```java
@Entity
public class Product {
    @Id
    private Long id;

    private String name;

    private int stock;

    @Version
    private Long version;  // JPA가 자동으로 관리
}

// 충돌 발생 시 OptimisticLockException 발생
```

### 비교표

| 구분 | 비관적 락 | 낙관적 락 |
|------|-----------|-----------|
| 락 사용 | O (데이터베이스 락) | X (버전 관리) |
| 충돌 처리 시점 | 트랜잭션 시작 시 | 커밋 시점 |
| 성능 | 낮음 (락 대기) | 높음 (락 없음) |
| 동시성 | 낮음 | 높음 |
| 데드락 | 발생 가능 | 발생 안 함 |
| 충돌 빈도 높을 때 | 유리 | 불리 (재시도 증가) |
| 충돌 빈도 낮을 때 | 불리 (불필요한 락) | 유리 |
| 구현 복잡도 | 낮음 | 중간 (재시도 로직) |

### 하이브리드 접근

실무에서는 두 방식을 혼합하여 사용하기도 합니다:

1. **읽기 작업**: 낙관적 락 또는 락 없이
2. **쓰기 작업**: 비관적 락으로 보호
3. **배치 작업**: 시간대를 분리하여 락 경합 최소화

## 핵심 정리
- **비관적 락**: 충돌을 미리 방지하기 위해 데이터베이스 락을 사용하는 방식
- **낙관적 락**: 충돌이 드물다고 가정하고 버전 관리로 검증하는 방식
- 충돌 빈도가 높으면 비관적 락, 낮으면 낙관적 락이 유리
- 비관적 락은 데드락 위험이 있지만 데이터 정합성을 확실히 보장
- 낙관적 락은 성능이 우수하지만 재시도 로직이 필요
- JPA는 `@Lock`, `@Version` 어노테이션으로 쉽게 구현 가능

## 키워드

### 비관적 락 (Pessimistic Lock)
트랜잭션이 데이터를 읽을 때 락을 걸어 다른 트랜잭션의 접근을 차단하는 동시성 제어 방식입니다. 충돌이 자주 발생할 것으로 예상되는 상황에서 사용하며, `SELECT ... FOR UPDATE` 구문을 통해 구현됩니다.

### 낙관적 락 (Optimistic Lock)
락을 사용하지 않고 버전 정보를 활용하여 커밋 시점에 충돌을 검증하는 동시성 제어 방식입니다. 충돌이 드물 것으로 예상되는 상황에서 사용하며, 성능이 우수하지만 충돌 시 재시도 로직이 필요합니다.

### SELECT FOR UPDATE
데이터베이스에서 비관적 락을 구현하기 위한 SQL 구문입니다. SELECT와 동시에 해당 행에 배타적 락(Exclusive Lock)을 걸어 다른 트랜잭션이 읽거나 수정하지 못하도록 막습니다.

### 버전 관리 (Versioning)
낙관적 락에서 충돌을 감지하기 위해 사용하는 메커니즘입니다. 각 레코드에 버전 컬럼을 두고, 업데이트 시 버전을 증가시키며, WHERE 절에 이전 버전 조건을 포함하여 충돌을 감지합니다.

### 데드락 (Deadlock)
두 개 이상의 트랜잭션이 서로가 가진 락을 기다리며 무한 대기 상태에 빠지는 현상입니다. 비관적 락 사용 시 발생할 수 있으며, 데이터베이스는 일반적으로 데드락을 감지하여 하나의 트랜잭션을 강제 롤백합니다.

### 동시성 (Concurrency)
여러 트랜잭션이 동시에 실행될 수 있는 정도를 의미합니다. 낙관적 락은 락을 사용하지 않아 높은 동시성을 제공하고, 비관적 락은 락으로 인해 동시성이 낮아집니다.

### 트랜잭션 격리 수준 (Transaction Isolation Level)
동시에 실행되는 트랜잭션 간의 데이터 접근 범위를 정의하는 수준입니다. READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE의 4단계가 있으며, 락 전략과 함께 동시성 제어에 중요한 역할을 합니다.

### 배타적 락 (Exclusive Lock)
비관적 락에서 사용되는 락의 종류로, 한 트랜잭션이 데이터를 수정하는 동안 다른 트랜잭션이 해당 데이터를 읽거나 수정할 수 없도록 막는 락입니다. X-Lock 또는 Write Lock이라고도 합니다.

### OptimisticLockException
JPA에서 낙관적 락 충돌이 발생했을 때 던져지는 예외입니다. 업데이트하려는 엔티티의 버전이 데이터베이스의 버전과 일치하지 않을 때 발생하며, 애플리케이션에서 이를 catch하여 재시도 로직을 구현합니다.

### 재시도 로직 (Retry Logic)
낙관적 락에서 충돌 발생 시 작업을 다시 시도하는 로직입니다. 일반적으로 지수 백오프(Exponential Backoff) 전략을 사용하여 일정 횟수만큼 재시도하며, 최대 재시도 횟수를 초과하면 예외를 발생시킵니다.

## 참고 자료
- [MySQL 공식 문서 - Locking Reads](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html)
- [PostgreSQL 공식 문서 - Explicit Locking](https://www.postgresql.org/docs/current/explicit-locking.html)
- [JPA 2.2 Specification - Pessimistic Locking](https://download.oracle.com/otn-pub/jcp/persistence-2_2-mrel-spec/JavaPersistence.pdf)
- [Hibernate 공식 문서 - Locking](https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#locking)
- [Oracle 공식 문서 - Transaction Isolation Levels](https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/data-concurrency-and-consistency.html)
